<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>xmlic by hidekatsu-izuno</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">xmlic</h1>
      <h2 class="project-tagline">jQuery like DOM traversal and manipulation API</h2>
      <a href="https://github.com/hidekatsu-izuno/xmlic" class="btn">View on GitHub</a>
      <a href="https://github.com/hidekatsu-izuno/xmlic/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/hidekatsu-izuno/xmlic/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="xmlic---jquery-like-dom-traversal-and-manipulation-api" class="anchor" href="#xmlic---jquery-like-dom-traversal-and-manipulation-api" aria-hidden="true"><span class="octicon octicon-link"></span></a>XMLIC - jQuery like DOM traversal and manipulation API</h1>

<h2>
<a id="xmlicズムリックとは" class="anchor" href="#xmlic%E3%82%BA%E3%83%A0%E3%83%AA%E3%83%83%E3%82%AF%E3%81%A8%E3%81%AF" aria-hidden="true"><span class="octicon octicon-link"></span></a>XMLIC（ズムリック）とは</h2>

<p>jQuery ライクな DOM 操作を実現する Java 用 XML APIです。JDOM や XOM などと異なり、あくまで W3C 標準の DOM に対し検索、操作を行なうため、XSLT など他ライブラリとの高い相互運用性を実現出来ます。API は jQuery に似ていますが、XMLIC は XML の操作に特化しているため、次のような違いがあります。</p>

<ul>
<li>CSS セレクタの代わりに XPath 1.0 および XPath パターンを使用します。</li>
<li>複数ドキュメントを扱うことができます。入出力機能も用意されています。</li>
<li>XML名前空間を適切に扱うことができます。</li>
</ul>

<p>使い方は簡単です。jQuery 利用者ならば、すぐに使いはじめることができるでしょう。</p>

<div class="highlight highlight-java"><pre><span class="pl-k">import</span> <span class="pl-smi">net.arnx.xmlic.XML</span>;

<span class="pl-c">// test.xml を読み込んで div タグに class="alert" という属性を設定します。</span>
<span class="pl-c1">XML</span><span class="pl-k">.</span>load(<span class="pl-k">new</span> <span class="pl-smi">File</span>(<span class="pl-s"><span class="pl-pds">"</span>test.xml<span class="pl-pds">"</span></span>))
    .find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)
    .attr(<span class="pl-s"><span class="pl-pds">"</span>class<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>alert<span class="pl-pds">"</span></span>);</pre></div>

<h2>
<a id="基本的な使い方" class="anchor" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E4%BD%BF%E3%81%84%E6%96%B9" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本的な使い方</h2>

<p>jQuery の Traversal/Manipulation API をそのままの仕様で移植していますので同じように操作が可能です。大きく違う点は、Document の取り回しです。 jQuery が単一の window.document に対して　XMLIC は複数のドキュメントを扱う必要があります。このような処理のためにXML クラスが用意されています（jQuery の $ 関数に当たるものだと考えるとわかりやすいでしょう）。</p>

<ul>
<li>読み込みには、 XML クラスの load() スタティックメソッドを使います。</li>
<li>読み込んだ XML インスタンスに対し、find() メソッドで Nodes インスタンスを取得し操作します（Nodes インスタンスは jQuery オブジェクトに当たるものだと考えるとよいでしょう）。</li>
<li>XML インスタンス は、Nodes インスタンスの getOwner() メソッドを通じて取得できます。</li>
<li>書き込みは、 XML インスタンスの writeTo() メソッドを使います。</li>
</ul>

<p>XPath は XSLT 1.0 パターンとして判定されます。そのため、子孫要素の div を捜すために find(".//div") のように記述する必要はなく、 find("div") と書くことができます。</p>

<h2>
<a id="xml-文書の読み込み---load" class="anchor" href="#xml-%E6%96%87%E6%9B%B8%E3%81%AE%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF---load" aria-hidden="true"><span class="octicon octicon-link"></span></a>XML 文書の読み込み - Load</h2>

<p>XML 文書の読み込みには、２パターンが用意されています。通常は XML クラスの load スタティックメソッドを使います。オプションは指定出来ませんが、通常の利用では困ることはないでしょう。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// ファイルから XML クラスのインスタンスを取得します。</span>
<span class="pl-smi">XML</span> xml <span class="pl-k">=</span> <span class="pl-c1">XML</span><span class="pl-k">.</span>load(<span class="pl-k">new</span> <span class="pl-smi">File</span>(<span class="pl-s"><span class="pl-pds">"</span>test.xml<span class="pl-pds">"</span></span>));

<span class="pl-c">// InputStream から XML クラスのインスタンスを取得します。クローズは自動的に行われます。</span>
<span class="pl-smi">XML</span> xml <span class="pl-k">=</span> <span class="pl-c1">XML</span><span class="pl-k">.</span>load(<span class="pl-k">new</span> <span class="pl-smi">FileInputStream</span>(<span class="pl-s"><span class="pl-pds">"</span>test.xml<span class="pl-pds">"</span></span>));

<span class="pl-c">// Reader から XML クラスのインスタンスを取得します。クローズは自動的に行われます。</span>
<span class="pl-smi">XML</span> xml <span class="pl-k">=</span> <span class="pl-c1">XML</span><span class="pl-k">.</span>load(<span class="pl-k">new</span> <span class="pl-smi">FileReader</span>(<span class="pl-s"><span class="pl-pds">"</span>test.xml<span class="pl-pds">"</span></span>));

<span class="pl-c">// URI から XML クラスのインスタンスを取得します。</span>
<span class="pl-smi">XML</span> xml <span class="pl-k">=</span> <span class="pl-c1">XML</span><span class="pl-k">.</span>load(<span class="pl-k">new</span> <span class="pl-smi">URI</span>(<span class="pl-s"><span class="pl-pds">"</span>http://...<span class="pl-pds">"</span></span>));</pre></div>

<p>検証を行なう必要があるなど、オプションの指定が必要な場合は、XMLLoader （あるいは DocumentBuilder などを通じて）構築した Document オブジェクトを XML クラスのコンストラクタを使ってラップします。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// XMLLoader から DOM を構築し、XML クラスでラップします。</span>
<span class="pl-smi">XMLLoader</span> loader <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">XMLLoader</span>();
loader<span class="pl-k">.</span>setValidation(<span class="pl-c1">true</span>);
loader<span class="pl-k">.</span>setIgnoringComments(<span class="pl-c1">true</span>);
<span class="pl-smi">XML</span> xml <span class="pl-k">=</span> loader<span class="pl-k">.</span>load(<span class="pl-k">new</span> <span class="pl-smi">FileInputStream</span>(<span class="pl-k">new</span> <span class="pl-smi">File</span>(<span class="pl-s"><span class="pl-pds">"</span>test.xml<span class="pl-pds">"</span></span>)));</pre></div>

<p>外部にあるドキュメントではなく、部分的な XML や DOM ノード値して構築されている場合は、 Nodes　コンストラクタを使って取り込みます。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// 部分的な XML をインラインで読み込みます。</span>
<span class="pl-smi">Nodes</span> nodes <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Nodes</span>(xml, <span class="pl-s"><span class="pl-pds">"</span>&lt;div&gt;部分的なXML&lt;/div&gt;&lt;div&gt;部分的なXML&lt;/div&gt;<span class="pl-pds">"</span></span>);

<span class="pl-c">// 構築済みのノードを Nodes オブジェクトに変換します。</span>
<span class="pl-smi">Node</span> node <span class="pl-k">=</span> <span class="pl-c1">...</span>;
<span class="pl-smi">Nodes</span> nodes <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Nodes</span>(xml, node);

<span class="pl-smi">NodeList</span> list <span class="pl-k">=</span> <span class="pl-c1">...</span>;
<span class="pl-smi">Nodes</span> nodes <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Nodes</span>(xml, list);</pre></div>

<h2>
<a id="dom-の検索---traversal" class="anchor" href="#dom-%E3%81%AE%E6%A4%9C%E7%B4%A2---traversal" aria-hidden="true"><span class="octicon octicon-link"></span></a>DOM の検索 - Traversal</h2>

<h3>
<a id="要素の検索---find" class="anchor" href="#%E8%A6%81%E7%B4%A0%E3%81%AE%E6%A4%9C%E7%B4%A2---find" aria-hidden="true"><span class="octicon octicon-link"></span></a>要素の検索 - find</h3>

<p>要素の検索には find メソッドを使います。find メソッドは、XML クラス、Nodes クラスの両方で利用できます。引数には、XPath 式を記述します。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// ドキュメントから div 要素を探し、さらに href 属性をもつ a 子要素を検索します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>a[@href]<span class="pl-pds">"</span></span>);</pre></div>

<p>名前空間に対して検索する場合は、プレフィックスを付与します。デフォルトでルート要素に付与された名前空間情報は収集しますが、読み込んだドキュメントに依存するため、明示的に指定する方がよいでしょう。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// XML インスタンスを構築し、利用する名前空間を指定します。</span>
<span class="pl-smi">XML</span> xml <span class="pl-k">=</span> <span class="pl-c1">XML</span><span class="pl-k">.</span>load(<span class="pl-k">new</span> <span class="pl-smi">File</span>(<span class="pl-s"><span class="pl-pds">"</span>test.xml<span class="pl-pds">"</span></span>));
xml<span class="pl-k">.</span>addNamespaceMapping(<span class="pl-s"><span class="pl-pds">"</span>h<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>http://www.w3.org/1999/xhtml<span class="pl-pds">"</span></span>);

<span class="pl-c">// ドキュメントから xhtml の div 要素を探し、さらに href 属性をもつ xhtml の a 子要素を検索します。</span>
<span class="pl-c">// 指定するプレフィックスは、ドキュメント内に実際に付与されたプレフィックスには依存しません。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>h:div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>h:a[@href]<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="ノードの検索---select" class="anchor" href="#%E3%83%8E%E3%83%BC%E3%83%89%E3%81%AE%E6%A4%9C%E7%B4%A2---select" aria-hidden="true"><span class="octicon octicon-link"></span></a>ノードの検索 - select</h3>

<p>XPath は、要素以外にもテキストノードや属性ノード、コメントノードなども対象にすることができます。 XMLIC では、それに対応して jQuery にはない select メソッドを追加しています。select メソッドは、XML クラス、Nodes クラスの両方で利用できます。引数には、XPath 式を記述します。属性値の設定／取得には val メソッドを使います。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// ドキュメントから最初の属性ノードを検索し、その値を取得します。</span>
xml<span class="pl-k">.</span>select(<span class="pl-s"><span class="pl-pds">"</span>attribute::node()[1]<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>val();</pre></div>

<p>jQuery では val メソッドは、入力タグに対する値を取得するメソッドとして用意されていますが、 XMLIC では、Node クラスの get/setNodeValue() に対するアクセッサとして機能します。</p>

<h3>
<a id="ノードの横断---traverse" class="anchor" href="#%E3%83%8E%E3%83%BC%E3%83%89%E3%81%AE%E6%A8%AA%E6%96%AD---traverse" aria-hidden="true"><span class="octicon octicon-link"></span></a>ノードの横断 - traverse</h3>

<p>DOM Level2 では、ノードを横断し列挙する機能が追加されましたが、XMLIC　にも対応する機能が用意されています。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// ドキュメントからすべての要素にマッチするノードを順番に訪問します。</span>
xml<span class="pl-k">.</span>traverse(<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-k">Visitor&lt;<span class="pl-smi">Nodes</span>&gt;</span>() {
  <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">visit</span>(<span class="pl-smi">Nodes</span> <span class="pl-v">current</span>, <span class="pl-smi">Status</span> <span class="pl-v">status</span>) {
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(current<span class="pl-k">.</span>name());
  }
});

<span class="pl-c">// 第3引数を true にすることで逆順にたどることもできます</span>
xml<span class="pl-k">.</span>traverse(<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-k">Visitor&lt;<span class="pl-smi">Nodes</span>&gt;</span>() {
  <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">visit</span>(<span class="pl-smi">Nodes</span> <span class="pl-v">current</span>, <span class="pl-smi">Status</span> <span class="pl-v">status</span>) {
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(current<span class="pl-k">.</span>name());
  }
}, <span class="pl-c1">true</span>);</pre></div>

<h3>
<a id="xpath-と-css-セレクタとの比較" class="anchor" href="#xpath-%E3%81%A8-css-%E3%82%BB%E3%83%AC%E3%82%AF%E3%82%BF%E3%81%A8%E3%81%AE%E6%AF%94%E8%BC%83" aria-hidden="true"><span class="octicon octicon-link"></span></a>XPath と CSS セレクタとの比較</h3>

<p>主要な XPath 式と findなどで用いるXPath パターンとCSS セレクタの対比表を次に示します。参考にしてください。</p>

<table>
<thead>
<tr>
<th>対象</th>
<th>XPath</th>
<th>XPath パターン</th>
<th>CSS セレクタ</th>
</tr>
</thead>
<tbody>
<tr>
<td>すべての要素</td>
<td>.//*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>要素が一致</td>
<td>.//element</td>
<td>element</td>
<td>element</td>
</tr>
<tr>
<td>子要素</td>
<td>.//parent/child</td>
<td>parent/child</td>
<td>parent &gt; child</td>
</tr>
<tr>
<td>子孫要素</td>
<td>.//ancestor//descendant</td>
<td>ancestor//descendant</td>
<td>ancestor descendant</td>
</tr>
<tr>
<td>属性がある</td>
<td>.//*[<a href="https://github.com/name" class="user-mention">@name</a>]</td>
<td>*[<a href="https://github.com/name" class="user-mention">@name</a>]</td>
<td>[name]</td>
</tr>
<tr>
<td>属性が一致</td>
<td>.//*[<a href="https://github.com/name" class="user-mention">@name</a>='value']</td>
<td>
<a href="https://github.com/name" class="user-mention">@name</a>='value'</td>
<td>[name='value']</td>
</tr>
<tr>
<td>n番目の子要素</td>
<td>.//*[n] あるいは .//*[position()=n]</td>
<td>*[n] あるいは *[position()=n]</td>
<td>:nth-child(n)</td>
</tr>
<tr>
<td>最初の子要素</td>
<td>.//*[1]</td>
<td>*[1]</td>
<td>:first-child</td>
</tr>
<tr>
<td>最後の子要素</td>
<td>.//*[last()]</td>
<td>*[last()]</td>
<td>:last-child</td>
</tr>
<tr>
<td>OR 条件選択</td>
<td>expr | ... | expr</td>
<td>expr | ... | expr</td>
<td>expr, ..., expr</td>
</tr>
</tbody>
</table>

<p>jQueryでは #ID の形でID指定を多用しますが、XMLではスキーマにID型が指定されない限り利用できないため、通常の属性同様 <a href="https://github.com/id" class="user-mention">@id</a>='ID' と記述します （XPath にも ID 構文は存在しますが、スキーマを使い検証を実施し DOM 内に ID 型であるという情報が設定されている場合に限り、id()='ID' と書くことで検索が可能です）。</p>

<h3>
<a id="子要素の取得---children" class="anchor" href="#%E5%AD%90%E8%A6%81%E7%B4%A0%E3%81%AE%E5%8F%96%E5%BE%97---children" aria-hidden="true"><span class="octicon octicon-link"></span></a>子要素の取得 - children</h3>

<p>子要素の取得には、children メソッドを使います。引数に XPathのフィルタ条件（角カッコの中）を記載することでフィルタリングが可能です。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// ドキュメントの中から div 要素を検索し、それらの要素に対する子要素の一覧を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>children();

<span class="pl-c">// ドキュメントの中から div 要素を検索し、span という名前を持つその子要素の一覧を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>children(<span class="pl-s"><span class="pl-pds">"</span>span<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="親要素の取得---parent-parents--parentsuntil-closest" class="anchor" href="#%E8%A6%AA%E8%A6%81%E7%B4%A0%E3%81%AE%E5%8F%96%E5%BE%97---parent-parents--parentsuntil-closest" aria-hidden="true"><span class="octicon octicon-link"></span></a>親要素の取得 - parent, parents / parentsUntil, closest</h3>

<p>親要素の取得には、parent メソッドを使います。すべての親（＝先祖）要素を取得する場合は parents メソッドを使います。 引数に XPathのフィルタ条件（角カッコの中）を記載することでフィルタリングが可能です。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// div 要素を検索し、それらの要素に対する親要素を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>parent();

<span class="pl-c">// div 要素を検索し、それらの要素にすべての親要素を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>parents();

<span class="pl-c">// フィルタリングも可能です。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>parent(<span class="pl-s"><span class="pl-pds">"</span>@class='test'<span class="pl-pds">"</span></span>);
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>parents(<span class="pl-s"><span class="pl-pds">"</span>@class='test'<span class="pl-pds">"</span></span>);</pre></div>

<p>条件に一致する親要素までを取得できる parentsUntil、自分も含むすべての親要素をから最初に条件に一致した要素を取得できる closest も同様に用意されています。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">//  div 要素を検索し、class="test" を持つ要素までの親要素を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>parentsUntil(<span class="pl-s"><span class="pl-pds">"</span>@class='test'<span class="pl-pds">"</span></span>);

<span class="pl-c">//  div 要素の自分も含む上位要素の中から、最初に条件に一致する要素を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>closest(<span class="pl-s"><span class="pl-pds">"</span>@class='test'<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="兄弟要素の取得---prev--prevuntil--prevall-next--nextuntil--nextall-siblings" class="anchor" href="#%E5%85%84%E5%BC%9F%E8%A6%81%E7%B4%A0%E3%81%AE%E5%8F%96%E5%BE%97---prev--prevuntil--prevall-next--nextuntil--nextall-siblings" aria-hidden="true"><span class="octicon octicon-link"></span></a>兄弟要素の取得 - prev / prevUntil / prevAll, next / nextUntil / nextAll, siblings</h3>

<p>兄弟要素の取得には、前にある要素を取得する prev 系メソッド、後にある要素を取得する next 系メソッド、前後両方の要素を取得する siblings メソッドがあります。</p>

<p>prev 系メソッドには、直前を取得する同名メソッドの他に、前に位置する兄弟要素すべてを取得する prevAll、 条件に一致するまで前にさかのぼる prevUntil があります。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// div 要素を検索し、それらの要素に対する直前の要素の一覧を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>prev();

<span class="pl-c">// div 要素を検索し、それらの要素に対して前にある要素すべての一覧を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>prevAll();

<span class="pl-c">// div 要素を検索し、それらの要素に対して条件に一致するまで前にある要素を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>prevUntil(<span class="pl-s"><span class="pl-pds">"</span>@class='test'<span class="pl-pds">"</span></span>);

<span class="pl-c">// フィルタリングも可能です。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>prev(<span class="pl-s"><span class="pl-pds">"</span>@class='test'<span class="pl-pds">"</span></span>);
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>prevAll(<span class="pl-s"><span class="pl-pds">"</span>@class='test'<span class="pl-pds">"</span></span>);</pre></div>

<p>next 系メソッドも同様に、直後を取得する同名メソッドの他に、後ろに位置する兄弟要素すべてを取得する nextAll、 条件に一致するまで後ろに進む nextUntil があります。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// div 要素を検索し、それらの要素に対する直後の要素の一覧を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>next();

<span class="pl-c">// div 要素を検索し、それらの要素に対して後ろにある要素すべての一覧を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>nextAll();

<span class="pl-c">// div 要素を検索し、それらの要素に対して条件に一致するまで後ろにある要素を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>nextUntil(<span class="pl-s"><span class="pl-pds">"</span>@class='test'<span class="pl-pds">"</span></span>);

<span class="pl-c">// フィルタリングも可能です。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>next(<span class="pl-s"><span class="pl-pds">"</span>@class='test'<span class="pl-pds">"</span></span>);
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>nextAll(<span class="pl-s"><span class="pl-pds">"</span>@class='test'<span class="pl-pds">"</span></span>);</pre></div>

<p>siblingsは、すべての兄弟要素を取得するメソッドで prevAll と nextAll を結合したような効果を持ちます。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// div 要素を検索し、それらの要素に対するすべての兄弟要素を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>siblings();

<span class="pl-c">// フィルタリングも可能です。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>siblings(<span class="pl-s"><span class="pl-pds">"</span>@class='test'<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="子ノードの取得---contents" class="anchor" href="#%E5%AD%90%E3%83%8E%E3%83%BC%E3%83%89%E3%81%AE%E5%8F%96%E5%BE%97---contents" aria-hidden="true"><span class="octicon octicon-link"></span></a>子ノードの取得 - contents</h3>

<p>子要素を取得するには、children メソッドを使いますが、テキストノードなどは除外されます。テキストノードやコメントノードなどすべての子ノードを取得する場合には、 contents メソッドを使います。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// div 要素を検索し、それらの要素に対するすべての子ノードを取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>contents();

<span class="pl-c">// フィルタリングも可能です。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>contents(<span class="pl-s"><span class="pl-pds">"</span>first()<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="取得結果の操作---filter--not-eq-first--last-slice" class="anchor" href="#%E5%8F%96%E5%BE%97%E7%B5%90%E6%9E%9C%E3%81%AE%E6%93%8D%E4%BD%9C---filter--not-eq-first--last-slice" aria-hidden="true"><span class="octicon octicon-link"></span></a>取得結果の操作 - filter / not, eq　/ first / last　/ slice</h3>

<p>取得結果をフィルタリングしたい場合は、filter メソッドを使います。filterメソッドには、XPath 式によるフィルタと、内部クラスを用いた２種類が用意されています。not メソッドは、filter とは逆に条件にマッチしないものだけを残します。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// div 要素を検索した結果に対し属性でフィルタリングします。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>filter(<span class="pl-s"><span class="pl-pds">"</span>@name='test'<span class="pl-pds">"</span></span>);

<span class="pl-c">// div 要素を検索した結果に対し条件にマッチしないものだけ残します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>not(<span class="pl-s"><span class="pl-pds">"</span>@name='test'<span class="pl-pds">"</span></span>);

<span class="pl-c">// div 要素を検索した結果に対しメソッドを使って属性ででフィルタリングします。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>filter(<span class="pl-k">new</span> <span class="pl-smi">Visitor</span>() {
    <span class="pl-k">public</span> <span class="pl-k">boolean</span> <span class="pl-en">visit</span>(<span class="pl-smi">Node</span> <span class="pl-v">node</span>) {
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>test<span class="pl-pds">"</span></span><span class="pl-k">.</span>equals(node<span class="pl-k">.</span>getAttributeNS(<span class="pl-c1">null</span>, <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>));
    }
});</pre></div>

<p>また、位置によるフィルタリングとして eq、first、lastの３メソッドが、位置範囲に 対するフィルタとして slice が用意されています。なお、first、last メソッドは、 それぞれ eq(0)、eq(-1) のショートカットです。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// div 要素を検索した結果の3番目を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>eq(<span class="pl-c1">3</span>);

<span class="pl-c">// div 要素を検索した結果の2～4番目を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>slice(<span class="pl-c1">2</span>, <span class="pl-c1">4</span>);</pre></div>

<p>jQuery の :first、:last とは異なり、XMLIC には結果集合それ自体に対して フィルタリングする XPath 式がないがめ、常にfirst()、last()を使う必要があることに注意して ください。</p>

<h3>
<a id="取得結果の結合---add-addback" class="anchor" href="#%E5%8F%96%E5%BE%97%E7%B5%90%E6%9E%9C%E3%81%AE%E7%B5%90%E5%90%88---add-addback" aria-hidden="true"><span class="octicon octicon-link"></span></a>取得結果の結合 - add, addBack</h3>

<p>取得結果に対し、別の検索結果を結合したい場合は、add メソッドを使います。一つ前の処理結果を現在の結果に結合したい場合は、 addBack　を使います。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// div 要素を検索した結果に p 要素を検索した結果を結合します。なお、次の二つの表現は等価です。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>add(<span class="pl-s"><span class="pl-pds">"</span>p<span class="pl-pds">"</span></span>);
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>add(xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>p<span class="pl-pds">"</span></span>));

<span class="pl-c">// div 要素の子要素  p を検索した結果に 最初の div 要素の検索結果を結合します。フィルタリングも可能です。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>p<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>addBack();</pre></div>

<h3>
<a id="取得結果の復元---end" class="anchor" href="#%E5%8F%96%E5%BE%97%E7%B5%90%E6%9E%9C%E3%81%AE%E5%BE%A9%E5%85%83---end" aria-hidden="true"><span class="octicon octicon-link"></span></a>取得結果の復元 - end</h3>

<p>一つ前の取得結果に戻したい場合は、 end メソッドを使います。このメソッドを使うことでメソッド連結でも入れ子表現が可能になります。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// div 要素を検索した結果に p 要素を検索した結果を結合した後、最初の検索結果を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)
  .find(<span class="pl-s"><span class="pl-pds">"</span>p<span class="pl-pds">"</span></span>)
.end();
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>p<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>addBack(<span class="pl-s"><span class="pl-pds">"</span>@name='test'<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="取得結果の列挙---each" class="anchor" href="#%E5%8F%96%E5%BE%97%E7%B5%90%E6%9E%9C%E3%81%AE%E5%88%97%E6%8C%99---each" aria-hidden="true"><span class="octicon octicon-link"></span></a>取得結果の列挙 - each</h3>

<p>Nodes クラスは、ArrayList を継承しているため、通常のリストと同様、for 文による列挙が可能です。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// 取得結果を列挙します。</span>
<span class="pl-k">for</span> (<span class="pl-smi">Node</span> node <span class="pl-k">:</span> xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)) {
  <span class="pl-smi">Nodes</span> current <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Nodes</span>(xml, node);
  <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(current<span class="pl-k">.</span>name());
}</pre></div>

<p>jQuery 同様に each メソッドによる列挙も可能です。ただし、 jQuery とはシンタックスが異なる点に注意が必要です。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// 取得結果を列挙します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>each(<span class="pl-k">new</span> <span class="pl-k">Visitor&lt;<span class="pl-smi">Nodes</span>&gt;</span>() {
  <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">visit</span>(<span class="pl-smi">Nodes</span> <span class="pl-v">current</span>, <span class="pl-smi">Status</span> <span class="pl-v">status</span>) {
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> status<span class="pl-k">.</span>getIndex() <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> current<span class="pl-k">.</span>name());
  }
});

<span class="pl-c">// 第ニ引数に true を設定することで、逆順の列挙も可能です。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>each(<span class="pl-k">new</span> <span class="pl-k">Visitor&lt;<span class="pl-smi">Nodes</span>&gt;</span>() {
  <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">visit</span>(<span class="pl-smi">Nodes</span> <span class="pl-v">current</span>, <span class="pl-smi">Status</span> <span class="pl-v">status</span>) {
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> status<span class="pl-k">.</span>getIndex() <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> current<span class="pl-k">.</span>name());
  }
}, <span class="pl-c1">true</span>);

<span class="pl-c">// 途中で break したい場合は cancel メソッドを使ってください。キャンセル例外が発生して処理を中断します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>each(<span class="pl-k">new</span> <span class="pl-k">Visitor&lt;<span class="pl-smi">Nodes</span>&gt;</span>() {
  <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">visit</span>(<span class="pl-smi">Nodes</span> <span class="pl-v">current</span>, <span class="pl-smi">Status</span> <span class="pl-v">status</span>) {
    <span class="pl-k">if</span> (status<span class="pl-k">.</span>getIndex() <span class="pl-k">==</span> <span class="pl-c1">3</span>) status<span class="pl-k">.</span>cancel();
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> status<span class="pl-k">.</span>getIndex() <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> current<span class="pl-k">.</span>name());
  }
});</pre></div>

<h2>
<a id="dom-の操作---manipulation" class="anchor" href="#dom-%E3%81%AE%E6%93%8D%E4%BD%9C---manipulation" aria-hidden="true"><span class="octicon octicon-link"></span></a>DOM の操作 - Manipulation</h2>

<h3>
<a id="名前の操作---name-namespace-prefix-localname" class="anchor" href="#%E5%90%8D%E5%89%8D%E3%81%AE%E6%93%8D%E4%BD%9C---name-namespace-prefix-localname" aria-hidden="true"><span class="octicon octicon-link"></span></a>名前の操作 - name, namespace, prefix, localName</h3>

<p>XML と HTML の大きな違いとして名前空間のサポートがあります。仕様としては自然なものですが XML の利用において最大の難物とも言えます。 まず、XML における名前の概念を整理すると次のようになります。なお、属性については、プレフィックスを付けない場合、名前空間はデフォルト名前空間 ではなく、要素の名前空間に属します。</p>

<table>
<thead>
<tr>
<th>概念</th>
<th>説明</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td>名前空間(Namespace URI)</td>
<td>タグセットの仕様を表す URI</td>
<td><a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a></td>
</tr>
<tr>
<td>プレフィックス(Prefix)</td>
<td>文書中での名前空間に対する短縮名</td>
<td>任意（hなど）</td>
</tr>
<tr>
<td>ローカル名(Local Name)</td>
<td>タグの要素や属性の名前</td>
<td>div、span など</td>
</tr>
<tr>
<td>修飾された名前（QName）</td>
<td>プレフィックスで修飾されたローカル名</td>
<td>h:div、h:span など</td>
</tr>
</tbody>
</table>

<p>名前空間導入以前の XML における名前やいわゆる タグ名（tagName）は、デフォルト名前空間で修飾された名前として扱われます。</p>

<p>jQuery には名前の操作機能がありませんが、XMLIC では、名前空間、プレフィックス、ローカル名、修飾された名前それぞれに対し namespace、prefix、localName、name メソッドでアクセスすることができます（複数のノードが含まれる場合は、先頭ノードの情報が返されます）。</p>

<div class="highlight highlight-java"><pre><span class="pl-smi">Nodes</span> nodes <span class="pl-k">=</span> xml<span class="pl-k">.</span>parse(<span class="pl-s"><span class="pl-pds">"</span>&lt;h:div xmlns:h=<span class="pl-cce">\"</span>http://www.w3.org/1999/xhtml<span class="pl-cce">\"</span>&gt;テスト&lt;/h:div&gt;<span class="pl-pds">"</span></span>);
nodes<span class="pl-k">.</span>namespace(); <span class="pl-c">// http://www.w3.org/1999/xhtml</span>
nodes<span class="pl-k">.</span>prefix(); <span class="pl-c">// h</span>
nodes<span class="pl-k">.</span>localName(); <span class="pl-c">// div</span>
nodes<span class="pl-k">.</span>name(); <span class="pl-c">// h:div</span></pre></div>

<p>変更する場合も、引数に値を設定するだけです。</p>

<div class="highlight highlight-java"><pre><span class="pl-smi">Nodes</span> nodes <span class="pl-k">=</span> xml<span class="pl-k">.</span>parse(<span class="pl-s"><span class="pl-pds">"</span>&lt;h:div xmlns:h=<span class="pl-cce">\"</span>http://www.w3.org/1999/xhtml<span class="pl-cce">\"</span>&gt;テスト&lt;/h:div&gt;<span class="pl-pds">"</span></span>);
<span class="pl-c">// プレフィックスは、文書中直近に指定されているものになります。存在しないときのみ、引数で指定したプレフィックスとなります。</span>
nodes<span class="pl-k">.</span>namespace(<span class="pl-s"><span class="pl-pds">"</span>http://www.w3.org/2000/svg<span class="pl-pds">"</span></span>);　<span class="pl-c">// デフォルトに戻す場合は、null を設定します。</span>
nodes<span class="pl-k">.</span>prefix(<span class="pl-s"><span class="pl-pds">"</span>svg<span class="pl-pds">"</span></span>); <span class="pl-c">// プレフィックスのみを変更します（名前空間は変わりません）</span>
nodes<span class="pl-k">.</span>localName(<span class="pl-s"><span class="pl-pds">"</span>span<span class="pl-pds">"</span></span>); <span class="pl-c">// ローカル名のみを変更します（名前空間は変わりません）</span>

<span class="pl-c">// XML 構築時に設定したプレフィクスで指定します。実際のプレフィックスは、文書中直近に指定されているものになります。</span>
<span class="pl-c">// 存在しないときのみ、引数で指定したプレフィックスとなります。</span>
nodes<span class="pl-k">.</span>name(<span class="pl-s"><span class="pl-pds">"</span>svg:span<span class="pl-pds">"</span></span>); <span class="pl-c">// svg　に紐づく名前空間と span というローカル名に変更されます。</span></pre></div>

<p>名前空間については removeNamespace メソッドを使うことで削除することも可能です。</p>

<div class="highlight highlight-java"><pre><span class="pl-smi">Nodes</span> nodes <span class="pl-k">=</span> xml<span class="pl-k">.</span>parse(<span class="pl-s"><span class="pl-pds">"</span>&lt;h:div xmlns:h=<span class="pl-cce">\"</span>http://www.w3.org/1999/xhtml<span class="pl-cce">\"</span>&gt;テスト&lt;/h:div&gt;<span class="pl-pds">"</span></span>);
<span class="pl-c">// ネームスペースを削除します。</span>
nodes<span class="pl-k">.</span>removeNamespace();

<span class="pl-c">// 特定のネームスペースだけを削除することもできます。</span>
nodes<span class="pl-k">.</span>removeNamespace(<span class="pl-s"><span class="pl-pds">"</span>http://www.w3.org/1999/xhtml<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="属性の操作" class="anchor" href="#%E5%B1%9E%E6%80%A7%E3%81%AE%E6%93%8D%E4%BD%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>属性の操作</h3>

<p>属性の操作は、attr メソッドを通じて行います。このメソッドも、名前同様に名前空間を考慮して操作することが可能です。</p>

<div class="highlight highlight-java"><pre>nodes<span class="pl-k">.</span>attr(<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>); <span class="pl-c">// 属性の値を取得します。</span>
nodes<span class="pl-k">.</span>attr(<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>) <span class="pl-c">// 属性の値を設定します。</span>

<span class="pl-c">// 名前空間の取り扱いも可能です。XML 構築時に設定したプレフィクスで指定します。</span>
nodes<span class="pl-k">.</span>attr(<span class="pl-s"><span class="pl-pds">"</span>http:name<span class="pl-pds">"</span></span>); <span class="pl-c">// 名前空間付きの属性の値を取得します。</span>

<span class="pl-c">// XML 構築時に設定したプレフィクスで指定します。属性が追加される場合、実際のプレフィックスは、文書中直近に指定されているものになります。</span>
<span class="pl-c">// 存在しないときのみ、引数で指定したプレフィックスとなります。</span>
nodes<span class="pl-k">.</span>attr(<span class="pl-s"><span class="pl-pds">"</span>http:name<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>) <span class="pl-c">// 名前空間を使って、属性を設定します。</span></pre></div>

<h3>
<a id="テキスト値の操作" class="anchor" href="#%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E5%80%A4%E3%81%AE%E6%93%8D%E4%BD%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>テキスト／値の操作</h3>

<p>要素の子要素となっているテキストの操作には、text メソッドを使用します。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// 子ノード（以下）に含まれるテキストを結合して返されます。</span>
nodes<span class="pl-k">.</span>text();

<span class="pl-c">// 子ノードをテキストで置換します。</span>
nodes<span class="pl-k">.</span>text(<span class="pl-s"><span class="pl-pds">"</span>text<span class="pl-pds">"</span></span>);</pre></div>

<p>XPath では、要素以外のノードについても検索が可能なため、属性やコメントなど要素以外のノード値を操作する方法が用意されています。 具体的には val メソッドを使います。jQuery にも val メソッドがありますが、異なる動作をしますので 注意してください（将来的には、input など同名の要素に対して同じ動作を実装することも検討しています。現在は要素に対しては何の動作もしません）。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// div　要素以下の最初のノードの値を取得します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>contents()<span class="pl-k">.</span>val();

<span class="pl-c">// div　要素以下の各種ノードの値を設定します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>contents()<span class="pl-k">.</span>val(<span class="pl-s"><span class="pl-pds">"</span>text<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="要素の評価---is-index" class="anchor" href="#%E8%A6%81%E7%B4%A0%E3%81%AE%E8%A9%95%E4%BE%A1---is-index" aria-hidden="true"><span class="octicon octicon-link"></span></a>要素の評価 - is, index</h3>

<p>要素が条件に一致するか調べたい場合には、is メソッドを使います。条件に一致するインデックス番号を取得したい場合には、indexメソッドを使います。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// すべての div 要素に属性 name="test"が存在する場合 true になります。</span>
<span class="pl-k">boolean</span> result <span class="pl-k">=</span> xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>is(<span class="pl-s"><span class="pl-pds">"</span>@name='test'<span class="pl-pds">"</span></span>);

<span class="pl-c">// div で最初に条件が一致したインデックス番号を返します。 見つからない場合は -1 を返します。</span>
<span class="pl-k">int</span> index <span class="pl-k">=</span> xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>index(<span class="pl-s"><span class="pl-pds">"</span>@name='test'<span class="pl-pds">"</span></span>);

<span class="pl-c">// フィルタの代わりに、Node を指定することもできます。</span>
<span class="pl-smi">Node</span> node <span class="pl-k">=</span> xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">'</span>div<span class="pl-pds">'</span></span>)<span class="pl-k">.</span>first()<span class="pl-k">.</span>get(<span class="pl-c1">0</span>);
<span class="pl-k">boolean</span> result <span class="pl-k">=</span> xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>is(node);
<span class="pl-k">int</span> index <span class="pl-k">=</span> xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>index(node);</pre></div>

<h3>
<a id="要素の追加---prepend--prependto-append--appendto-before--insertbefore-after--insertafter" class="anchor" href="#%E8%A6%81%E7%B4%A0%E3%81%AE%E8%BF%BD%E5%8A%A0---prepend--prependto-append--appendto-before--insertbefore-after--insertafter" aria-hidden="true"><span class="octicon octicon-link"></span></a>要素の追加 - prepend / prependTo, append / appendTo, before / insertBefore, after / insertAfter</h3>

<p>要素を追加したい場合は、prepend系、append系、before系、after 系の各メソッドを使います。 これらのメソッドは、それぞれ挿入位置が違うだけで、同じような使い方ができます。</p>

<p>prepend、append、before、after と prependTo、appendTo、insertBefore、insertAfter の違いは、前者がオブジェクトの要素群に引数で指定した要素群を加えるのに対し、後者は、引数で指定した要素群にオブジェクトの要素群を加える点にあります（対象が逆になる）。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// すべての div 要素に指定した要素を追加します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>prepend(<span class="pl-s"><span class="pl-pds">"</span>&lt;span&gt;最初の子要素として追加！&lt;/span&gt;<span class="pl-pds">"</span></span>);
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>append(<span class="pl-s"><span class="pl-pds">"</span>&lt;span&gt;最後の子要素として追加！&lt;/span&gt;<span class="pl-pds">"</span></span>);
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>before(<span class="pl-s"><span class="pl-pds">"</span>&lt;span&gt;直前の要素として追加！&lt;/span&gt;<span class="pl-pds">"</span></span>);
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>after(<span class="pl-s"><span class="pl-pds">"</span>&lt;span&gt;直後の要素として追加！&lt;/span&gt;<span class="pl-pds">"</span></span>);

<span class="pl-c">// 同じ結果になりますが記述が逆転します。</span>
xml<span class="pl-k">.</span>parse(<span class="pl-s"><span class="pl-pds">"</span>&lt;span&gt;最初の子要素として追加！&lt;/span&gt;<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>prependTo(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>);
xml<span class="pl-k">.</span>parse(<span class="pl-s"><span class="pl-pds">"</span>&lt;span&gt;最後の子要素として追加！&lt;/span&gt;<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>appendTo(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>);
xml<span class="pl-k">.</span>parse(<span class="pl-s"><span class="pl-pds">"</span>&lt;span&gt;直前の要素として追加！&lt;/span&gt;<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>insertBefore(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>);
xml<span class="pl-k">.</span>parse(<span class="pl-s"><span class="pl-pds">"</span>&lt;span&gt;直後の要素として追加！&lt;/span&gt;<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>insertAfter(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="要素の置換---replacewith--replaceall" class="anchor" href="#%E8%A6%81%E7%B4%A0%E3%81%AE%E7%BD%AE%E6%8F%9B---replacewith--replaceall" aria-hidden="true"><span class="octicon octicon-link"></span></a>要素の置換 - replaceWith / replaceAll</h3>

<p>要素の置換には、replaceWith メソッドと replaceAll メソッドを使います。ふたつのメソッドの違いは、要素の追加と同様に置換対象と置換内容の記述位置だけです。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// すべての div 要素を指定した要素で置換します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>replaceWith(<span class="pl-s"><span class="pl-pds">"</span>&lt;span&gt;最初の子要素として追加！&lt;/span&gt;<span class="pl-pds">"</span></span>);

<span class="pl-c">// 同じ結果になりますが記述が逆転します。</span>
xml<span class="pl-k">.</span>parse(<span class="pl-s"><span class="pl-pds">"</span>&lt;span&gt;最初の子要素として追加！&lt;/span&gt;<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>replaceAll(<span class="pl-s"><span class="pl-pds">"</span>//div<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="要素のラッピング---wrap--wrapinner--wrapall--unwrap" class="anchor" href="#%E8%A6%81%E7%B4%A0%E3%81%AE%E3%83%A9%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0---wrap--wrapinner--wrapall--unwrap" aria-hidden="true"><span class="octicon octicon-link"></span></a>要素のラッピング - wrap / wrapInner / wrapAll / unwrap</h3>

<p>要素のラッピングには、wrap 系メソッドを使います。wrap は要素自身を、wrapInner は要素の内側をラッピングします。 unwrap は wrap とは反対にラッピングを解除し、子要素で置換します。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// すべての div 要素を指定した要素でラップします。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>wrap(<span class="pl-s"><span class="pl-pds">"</span>&lt;div class=<span class="pl-pds">"</span></span><span class="pl-k">.</span>wrap<span class="pl-s"><span class="pl-pds">"</span>&gt;&lt;/div&gt;<span class="pl-pds">"</span></span>); <span class="pl-c">// &gt;&lt;の間に要素が挿入されます。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>unwrap(); <span class="pl-c">// すべての div 要素のラッピングを解除します。</span>

<span class="pl-c">// すべての div 要素の内側を指定した要素でラップします。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>wrapInner(<span class="pl-s"><span class="pl-pds">"</span>&lt;div class=<span class="pl-pds">"</span></span><span class="pl-k">.</span>wrap<span class="pl-s"><span class="pl-pds">"</span>&gt;&lt;/div&gt;<span class="pl-pds">"</span></span>);
wrapAll は、対象となる要素の最初の位置に対象のすべての要素を包み込むようにラッピングします。

<span class="pl-c">// 最初の div 要素の位置にすべての div 要素がラッピングされるように移動されます。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>wrapInner(<span class="pl-s"><span class="pl-pds">"</span>&lt;div class=<span class="pl-pds">"</span></span><span class="pl-k">.</span>wrap<span class="pl-s"><span class="pl-pds">"</span>&gt;&lt;/div&gt;<span class="pl-pds">"</span></span>);</pre></div>

<h3>
<a id="要素の削除---remove-empty" class="anchor" href="#%E8%A6%81%E7%B4%A0%E3%81%AE%E5%89%8A%E9%99%A4---remove-empty" aria-hidden="true"><span class="octicon octicon-link"></span></a>要素の削除 - remove, empty</h3>

<p>要素を削除するメソッドとしては、要素自身を含めて削除する remove メソッドと要素の内側を削除する empty メソッドがあります。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// すべての div 要素を削除します。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>remove();
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>remove(<span class="pl-s"><span class="pl-pds">"</span>span<span class="pl-pds">"</span></span>); <span class="pl-c">// マッチした要素だけを削除することも可能です。</span>

<span class="pl-c">// すべての div 要素を空（＝内側を削除）にします。</span>
xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>empty();</pre></div>

<h3>
<a id="ノードの複製---clone" class="anchor" href="#%E3%83%8E%E3%83%BC%E3%83%89%E3%81%AE%E8%A4%87%E8%A3%BD---clone" aria-hidden="true"><span class="octicon octicon-link"></span></a>ノードの複製 - clone</h3>

<p>ノードを複製したい場合は、clone メソッドを使用します。</p>

<div class="highlight highlight-java"><pre><span class="pl-smi">Nodes</span> clone <span class="pl-k">=</span> xml<span class="pl-k">.</span>find(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>clone();</pre></div>

<h3>
<a id="ノードの評価---evaluate" class="anchor" href="#%E3%83%8E%E3%83%BC%E3%83%89%E3%81%AE%E8%A9%95%E4%BE%A1---evaluate" aria-hidden="true"><span class="octicon octicon-link"></span></a>ノードの評価 - evaluate</h3>

<p>XPath では、ノードの選択の他に文字列/数値/真偽値の結果を返す場合があります。XMLIC には、そのような場合にも対応できるように、evaluate という汎用の XPath 評価メソッドを用意しています。引数には、 xpath と戻り値の型を指定します。型には、Nodes、NodeList、 Node、String、Boolean / boolean、各種数値型（Numberのサブクラス） を指定することができます。</p>

<div class="highlight highlight-java"><pre><span class="pl-k">if</span> (nodes<span class="pl-k">.</span>evaluate(<span class="pl-s"><span class="pl-pds">"</span>self::node()[@name='test']<span class="pl-pds">"</span></span>, <span class="pl-k">boolean</span><span class="pl-k">.</span>class)) {
  <span class="pl-c">// マッチした！</span>
}</pre></div>

<h3>
<a id="ノードの正規化---normalize" class="anchor" href="#%E3%83%8E%E3%83%BC%E3%83%89%E3%81%AE%E6%AD%A3%E8%A6%8F%E5%8C%96---normalize" aria-hidden="true"><span class="octicon octicon-link"></span></a>ノードの正規化 - normalize</h3>

<p>normalize メソッドは、ノードの正規化を行います。具体的には、子要素より下にあるテキストノードを結合してひとつのノードにまとめます。これは、Node クラスの normalize の動作と同じですが、XMLIC ではこの動作に加え、不用な名前空間宣言の除去も行います。</p>

<div class="highlight highlight-java"><pre>nodes<span class="pl-k">.</span>normalize();</pre></div>

<h3>
<a id="データの紐付け---dataremovedata" class="anchor" href="#%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E7%B4%90%E4%BB%98%E3%81%91---dataremovedata" aria-hidden="true"><span class="octicon octicon-link"></span></a>データの紐付け - data/removeData</h3>

<p>DOM の属性などにはしたくないが、特定のノードとオブジェクトを紐付けておきたい場合には Data APIを利用します。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// ノードにオブジェクトを紐付けます。</span>
nodes<span class="pl-k">.</span>data(<span class="pl-s"><span class="pl-pds">"</span>key<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>value<span class="pl-pds">"</span></span>);

<span class="pl-c">// ノードからオブジェクトを取得します。</span>
<span class="pl-smi">Object</span> value <span class="pl-k">=</span> nodes<span class="pl-k">.</span>data(<span class="pl-s"><span class="pl-pds">"</span>key<span class="pl-pds">"</span></span>);

<span class="pl-c">// ノードからオブジェクトを削除します。</span>
nodes<span class="pl-k">.</span>removeData(<span class="pl-s"><span class="pl-pds">"</span>key<span class="pl-pds">"</span></span>);</pre></div>

<p>なお、jQuery同様「data-名前」という属性がある場合には、Data API から取得できるデフォルト値として扱います。</p>

<h3>
<a id="html互換機能---addclasstoggleclassremoveclasshasclass-css" class="anchor" href="#html%E4%BA%92%E6%8F%9B%E6%A9%9F%E8%83%BD---addclasstoggleclassremoveclasshasclass-css" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTML互換機能 - addClass/toggleClass/removeClass/hasClass, css</h3>

<p>XMLIC は XML を対象としていますが、XHTML での操作時に便利なように次の jQuery ライクな HTML 互換操作機能を用意しています。</p>

<ul>
<li>addClass、removeClass はそれぞれ要素の class 属性の空白文字で区切られたリストに文字列を追加／削除します。</li>
<li>toggleClass は、フラグにより要素の追加、削除を入れ替えます。</li>
<li>hasClass は、要素の class 属性の空白文字で区切られたリストに指定した文字列が含まれているかを確認します。</li>
</ul>

<div class="highlight highlight-java"><pre><span class="pl-c">// クラスを追加します。複数追加するときは空白で区切ります。</span>
nodes<span class="pl-k">.</span>addClass(<span class="pl-s"><span class="pl-pds">"</span>warning error<span class="pl-pds">"</span></span>);

<span class="pl-c">// クラスを削除します</span>
nodes<span class="pl-k">.</span>removeClass(<span class="pl-s"><span class="pl-pds">"</span>warning<span class="pl-pds">"</span></span>);

<span class="pl-c">// クラスを入れ替えます。</span>
nodes<span class="pl-k">.</span>removeClass(<span class="pl-s"><span class="pl-pds">"</span>warning<span class="pl-pds">"</span></span>, warning <span class="pl-k">!=</span> <span class="pl-c1">null</span>);

<span class="pl-c">// クラスが存在しているかチェックします。</span>
<span class="pl-k">if</span> (nodes<span class="pl-k">.</span>hasClass(<span class="pl-s"><span class="pl-pds">"</span>error<span class="pl-pds">"</span></span>)) {
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>エラーはまだ存在しています。<span class="pl-pds">"</span></span>);
}</pre></div>

<p>css メソッドは、要素の style 属性に対し CSSスタイルを取得／追加／削除します。jQuery とは異なり、link要素やstyle要素で指定されたスタイル情報ができるわけではないので、注意してください。</p>

<h2>
<a id="xml-文書の出力---write" class="anchor" href="#xml-%E6%96%87%E6%9B%B8%E3%81%AE%E5%87%BA%E5%8A%9B---write" aria-hidden="true"><span class="octicon octicon-link"></span></a>XML 文書の出力 - Write</h2>

<p>XML 文書の出力も読み込み同様に２パターンが用意されています。通常は XML クラスの writeTo メソッドを使います。オプションは指定出来ませんが、通常の利用には十分でしょう。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// ファイルに  DOM の内容を出力します。</span>
xml<span class="pl-k">.</span>writeTo(<span class="pl-k">new</span> <span class="pl-smi">File</span>(<span class="pl-s"><span class="pl-pds">"</span>test.xml<span class="pl-pds">"</span></span>));

<span class="pl-c">// OutputStream に  DOM の内容を出力します。クローズは自動的に行われます。</span>
xml<span class="pl-k">.</span>writeTo(<span class="pl-k">new</span> <span class="pl-smi">FileOutputStream</span>(<span class="pl-s"><span class="pl-pds">"</span>test.xml<span class="pl-pds">"</span></span>));

<span class="pl-c">// Writer に DOM の内容を出力します。クローズは自動的に行われます。</span>
xml<span class="pl-k">.</span>writeTo(<span class="pl-k">new</span> <span class="pl-smi">OutputStreamWriter</span>(<span class="pl-k">new</span> <span class="pl-smi">FileOutputStream</span>(<span class="pl-s"><span class="pl-pds">"</span>test.xml<span class="pl-pds">"</span></span>), <span class="pl-s"><span class="pl-pds">"</span>Windows-31J<span class="pl-pds">"</span></span>));</pre></div>

<p>改行コードの変更などオプションの指定が必要な場合は、XMLWriter を使います。</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// DOM を XMLWrite に渡しファイルに出力します。</span>
<span class="pl-smi">XMLWriter</span> writer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">XMLWriter</span>();
writer<span class="pl-k">.</span>setEncoding(<span class="pl-s"><span class="pl-pds">"</span>EUC-JP<span class="pl-pds">"</span></span>);
writer<span class="pl-k">.</span>setLineSeparator(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>);
writer<span class="pl-k">.</span>setPrettyPrinting(<span class="pl-c1">true</span>);

writer<span class="pl-k">.</span>writeTo(<span class="pl-k">new</span> <span class="pl-smi">FileOutputStream</span>(<span class="pl-s"><span class="pl-pds">"</span>test.xml<span class="pl-pds">"</span></span>), xml);</pre></div>

<p>部分的な XML を出力したい場合は、toString でも取得出来ます。</p>

<h2>
<a id="mavenリポジトリ" class="anchor" href="#maven%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mavenリポジトリ</h2>

<p>XMLIC は、0.9.1 以降 Maven Central Repository に登録されるようになりました。groupId、artifactIdは次の通りです。</p>

<div class="highlight highlight-xml"><pre>&lt;<span class="pl-ent">groupId</span>&gt;net.arnx&lt;/<span class="pl-ent">groupId</span>&gt;
&lt;<span class="pl-ent">artifactId</span>&gt;xmlic&lt;/<span class="pl-ent">artifactId</span>&gt;</pre></div>

<h2>
<a id="ライセンス" class="anchor" href="#%E3%83%A9%E3%82%A4%E3%82%BB%E3%83%B3%E3%82%B9" aria-hidden="true"><span class="octicon octicon-link"></span></a>ライセンス</h2>

<p>XMLIC は、Apache License, Version 2.0下で配布します。</p>

<p>自分のライブラリへの組み込んでいただいたり、その際にパッケージ名の変更や処理の変更など行っていただいても何ら構いません。ライセンスの範囲内でご自由にお使いください。</p>

<p>なお、 XMLIC は jaxen をパッケージを変更し同梱しています。その部分に関しては jaxen のライセンスに従ってください（Apache ライセンスに準じた緩いライセンスとなっていますので、特別な考慮は必要はありません）。</p>

<h2>
<a id="リリースノート" class="anchor" href="#%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B9%E3%83%8E%E3%83%BC%E3%83%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>リリースノート</h2>

<h3>
<a id="201574-version-103" class="anchor" href="#201574-version-103" aria-hidden="true"><span class="octicon octicon-link"></span></a>2015/7/4 version 1.0.3</h3>

<ul>
<li>すでに root 要素が存在してる XML オブジェクトに root メソッドで要素を設定するとエラーが発生する問題を修正しました。</li>
<li>Nods クラスに JavaScript 互換の sort() メソッドを追加しました。</li>
</ul>

<h3>
<a id="201431-version-102" class="anchor" href="#201431-version-102" aria-hidden="true"><span class="octicon octicon-link"></span></a>2014/3/1 version 1.0.2</h3>

<ul>
<li>Nodes クラスに JavaScript 互換の reverse() メソッドを追加しました。</li>
<li>Nodes クラスに jQuery 同様の addClass/toggleClass/removeClass/hasClass, css を追加しました。</li>
</ul>

<h3>
<a id="2013118-version-101" class="anchor" href="#2013118-version-101" aria-hidden="true"><span class="octicon octicon-link"></span></a>2013/11/8 version 1.0.1</h3>

<ul>
<li>Nodes クラスに owner() メソッドを追加するとともに、getOwner() メソッドを非推奨にしました 。</li>
<li>Nodes クラスに jQuery 同様の Data API を追加しました。</li>
<li>Nodes クラスにて別のドキュメントの要素を append/prepend/before/after した際、エラーが発生していた問題を修正しました。</li>
</ul>

<h3>
<a id="2013918-version-100" class="anchor" href="#2013918-version-100" aria-hidden="true"><span class="octicon octicon-link"></span></a>2013/9/18 version 1.0.0</h3>

<ul>
<li>XML や XSLT のロード時に発生する例外を XMLException に統一しました。個々のエラーにもアクセスすることができます。XML　や XMLException の getWarnings() メソッドを通じて警告にもアクセスできます。</li>
<li>XSLT を取り扱う XSLT クラスを追加しました。</li>
<li>XMLLoader#load の戻り値を Document から XML クラスに変更しました。</li>
<li>XMLWriter#writeTo に XML クラスを引数にとるメソッドを追加しました。</li>
<li>XML#parse を廃止し、 new Nodes(XML, String) コンストラクタに変更しました。</li>
</ul>

<h3>
<a id="2013825-version-092" class="anchor" href="#2013825-version-092" aria-hidden="true"><span class="octicon octicon-link"></span></a>2013/8/25 version 0.9.2</h3>

<ul>
<li>ロード時の名前空間走査処理をルートノードだけに限定しました。</li>
<li>デフォルト名前空間が指定された場合の XPath 式の取り扱いを XSLT2.0 の xpath-default-namespace 属性設定に合わせました。</li>
<li>HTML 互換機能として addClass, css メソッドを追加しました。</li>
<li>各クラス／メソッドにコメントを追加しました。</li>
<li>StatusImpl を internal パッケージに移動しました。</li>
</ul>

<h3>
<a id="2013817-version-091" class="anchor" href="#2013817-version-091" aria-hidden="true"><span class="octicon octicon-link"></span></a>2013/8/17 version 0.9.1</h3>

<ul>
<li>each、filter など繰り返し処理の引数インターフェイスを Java で利用しやすいように見直しました。</li>
<li>DOM2 Traversal API に対応した traverse メソッドを追加しました。</li>
</ul>

<h3>
<a id="201388-version-090" class="anchor" href="#201388-version-090" aria-hidden="true"><span class="octicon octicon-link"></span></a>2013/8/8 version 0.9.0</h3>

<ul>
<li>XPath 式として XSLT 1.0 パターンを使うように変更しました。これにより .// のような記述が必要なくなり、より jQuery に近い書き方が可能になりました。 ただし、 select/evaluate は従来通り通常の XPath として解釈します。</li>
<li>空のドキュメントに append できない不具合を修正しました。また、XMLクラスに XML文字列を指定できるコンストラクタを追加しました。</li>
<li>XMLエスケープ用に XML.escape(str)/XML.unescape(str) を追加しました。</li>
<li>XPath 関数として XSLT 同様の動作をする key() 関数を追加しました。</li>
</ul>

<h3>
<a id="201383-version-082" class="anchor" href="#201383-version-082" aria-hidden="true"><span class="octicon octicon-link"></span></a>2013/8/3 version 0.8.2</h3>

<ul>
<li>XPath API の動作が導入するライブラリによって結構異なることがわかったので　jaxen を統合しました（jar 内にパッケージを変更して入れたので、他に jar を追加する必要はありません）。</li>
<li>サンプルで　//foo となっていた部分を .//foo に修正しました。</li>
<li>Translater は Mapper に名前を変更するとともに、Nodes を取得するように変更しました。</li>
<li>XML.load で読み込んだ時にネームスペースマッピングを変更する方法がなかった問題を改善しました。</li>
<li>XPath 関数としてXSLT同様の動作をする document() と current() を追加しました。</li>
</ul>

<h3>
<a id="2013716-version-081" class="anchor" href="#2013716-version-081" aria-hidden="true"><span class="octicon octicon-link"></span></a>2013/7/16 version 0.8.1</h3>

<ul>
<li>命名や動作が一貫していなかった点をいろいろ修正しました。</li>
<li>デフォルト名前空間の NamespaceContext での扱いが不適切でしたので修正しました。</li>
<li>ドキュメントを拡充しました。</li>
</ul>

<h3>
<a id="2013716-version-080" class="anchor" href="#2013716-version-080" aria-hidden="true"><span class="octicon octicon-link"></span></a>2013/7/16 version 0.8.0</h3>

<ul>
<li>XMLIC 最初のリリースとなります。元となる仕様が jQuery API ですので大きな変更は予定していませんが、1.0 までは不具合、要望など積極的に取り入れたいと思いますので、ご要望あれば是非。</li>
</ul>

<p>Copyright (c) 2013 Hidekatsu Izuno Licensed under the <a href="LICENSE.txt">Apache License 2.0</a>.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/hidekatsu-izuno/xmlic">xmlic</a> is maintained by <a href="https://github.com/hidekatsu-izuno">hidekatsu-izuno</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

