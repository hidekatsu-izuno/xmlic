<!doctype html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>XMLIC - jQuery like DOM traversal and manipulation API</title>
<link rel="stylesheet" href="css/common.css" />
<style>
.sourceforge { position: absolute; top: 5px; right: 10px; }
</style>
</head>
<body>
<div class="nav">
<h1 class="logo"><a href="#"><img src="img/xmlic.jpg" alt="XMLIC" width="115" height="34" /></a></h1>
<div class="bar">version 0.8.0</div>
<ul class="menu">
	<li><a href="#introduction">XMLICとは</a></li>
	<li><a href="#download">ダウンロード</a></li>
	<li><a href="#usage">基本的な使い方</a></li>
	<li><a href="#load">XML文書の読み込み</a></li>
	<li><a href="#traversal">DOMの検索</a>
		<ul>
			<li><a href="#find">要素の検索</a></li>
			<li><a href="#select">ノードの検索</a></li>
			<li><a href="#xpath">XPathとCSSセレクタとの比較</a></li>
			<li><a href="#children">子要素の取得</a></li>
			<li><a href="#parent">親要素の取得</a></li>
			<li><a href="#sibling">兄弟要素の取得</a></li>
			<li><a href="#contents">子ノードの取得</a></li>
			<li><a href="#filter">取得結果の操作</a></li>
			<li><a href="#add">取得結果の結合</a></li>
			<li><a href="#end">取得結果の復元</a></li>
		</ul>
	</li>
	<li><a href="#manipulation">DOMの操作</a>
		<ul>
			<li><a href="#name">名前の操作</a></li>
			<li><a href="#attr">属性の操作</a></li>
			<li><a href="#text">テキスト／値の操作</a></li>
			<li><a href="#is">要素の評価</a></li>
			<li><a href="#append">要素の追加</a></li>
			<li><a href="#replace">要素の置換</a></li>
			<li><a href="#remove">要素の削除</a></li>
			<li><a href="#remove">要素の複製</a></li>
			<li><a href="#evaluate">ノードの評価</a></li>
			<li><a href="#normalize">ノードの正規化</a></li>
		</ul>
	</li>
	<li><a href="#writo">XML文書の出力</a></li>
	<li>API リファレンス
		<ul>
			<li><a href="http://xmlic.sourceforge.jp/api/index.html">javadoc</a></li>
		</ul>
	</li>
	<li><a href="#license">ライセンス</a></li>
	<li><a href="#report">バグ・要望の報告先</a></li>
	<li><a href="#releasenote">リリースノート</a></li>
</ul>
</div>
<div class="header">
<h1><span class="title">XMLIC</span> <span class="sub">- jQuery like DOM traversal and manipulation API</span></h1>
<div class="sourceforge"><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=8657&type=1" width="96" height="31" border="0" alt="SourceForge.JP"></a></div>
<div class="bar">&nbsp;</div>
</div>
<div class="main">

<h2 id="introduction" style="margin-top: 0px;">XMLIC（ズムリック）とは</h2>
<p>jQuery ライクな DOM 操作を実現する Java 用 XML APIです。JDOM や XOM などと異なり、あくまで W3C 標準の DOM に対し検索、操作を行なうため、XSLT など他ライブラリとの高い相互運用性を実現出来ます。<br />
API の使い方は jQuery に似ていますが、XMLIC は XML の操作に特化しているため、次のような違いがあります。</p>
<ul>
<li>CSS セレクタの代わりに XPath を使用します。</li>
<li>複数ドキュメントを扱うことができます。入出力機能も用意されています。</li>
<li>XML名前空間を適切に扱うことができます。</li>
</ul>
<p>使い方は簡単です。jQuery 利用者ならば、すぐに使いはじめることができるでしょう。</p>
<pre class="source">
import net.arnx.xmlic.XML;

<span class="comment">// test.xml を読み込んで div タグに class="alert" という属性を設定します。</span>
XML.load(new File("test.xml"))
    .find("//div")
    .attr("class", "alert");
</pre>

<h2 id="download">ダウンロード</h2>
<p><a href="http://sourceforge.jp/projects/xmlic">ダウンロードはこちらから</a>可能です。なお、XMLICのビルド/実行には、Java SE 6 以上が必要です。</p>
<script src="http://sourceforge.jp/projects/xmlic/releases/compact.js" type="text/javascript" charset="utf-8"></script>

<h2 id="usage">基本的な使い方</h2>
<p>jQuery の Traversal/Manipulation API をそのままの仕様で移植していますので同じように操作が可能です。大きく違う点は、<code>Document</code> の取り回しです。
jQuery が単一の <code>window.document</code> に対して　XMLIC は複数のドキュメントを扱う必要があります。このような処理のために<code>XML</code> クラスが用意されています（jQuery の <code>$</code> 関数に当たるものだと考えるとわかりやすいでしょう）。</p>
<ul>
<li>読み込みには、 <code>XML</code> クラスの <code>load()</code> スタティックメソッドを使います。</li>
<li>読み込んだ  <code>XML</code> インスタンスに対し、<code>find()</code> メソッドで <code>Nodes</code> インスタンスを取得し操作します（<code>Nodes</code> インスタンスは <code>jQuery</code> オブジェクトに当たるものだと考えるとよいでしょう）。</li>
<li><code>Nodes</code> インスタンスからは <code>getOwner()</code> メソッドを通じて <code>XML</code> インスタンスにいつでもアクセスできます。</li>
<li>書き込みは、 <code>XML</code> インスタンスの <code>writeTo()</code> メソッドを使います。</li>
</ul>
<p>なお、XPath は jQuery セレクタより機能が豊富ですが違いも大きいので注意が必要です。例えば <code>find("div")</code> と記述した場合、
jQuery では子孫ノードすべてが対象になりますが、XPath で同じ動作を実現するには <code>find("//div")</code> と記述する必要があります。</p>

<h2 id="load">XML 文書の読み込み <span class="sub">- Load</span></h2>

<p>XML 文書の読み込みには、２パターンが用意されています。通常は <code>XML</code> クラスの <code>load</code> スタティックメソッドを使います。オプションは指定出来ませんが、通常の利用では困ることはないでしょう。</p>
<pre class="source">
<span class="comment">// ファイルから <code>XML</code> クラスのインスタンスを取得します。</span>
XML xml = XML.load(new File("test.xml"));

<span class="comment">// <code>InputStream</code> から <code>XML</code> クラスのインスタンスを取得します。クローズは自動的に行われます。</span>
XML xml = XML.load(new FileInputStream("test.xml"));

<span class="comment">// <code>Reader</code> から <code>XML</code> クラスのインスタンスを取得します。クローズは自動的に行われます。</span>
XML xml = XML.load(new FileReader("test.xml"));

<span class="comment">// <code>URI</code> から <code>XML</code> クラスのインスタンスを取得します。</span>
XML xml = XML.load(new URI("http://..."));
</pre>

<p>検証を行なう必要があるなど、オプションの指定が必要な場合は、<code>XMLLoader</code> （あるいは <code>DocumentBuilder</code> などを通じて）構築した Document 
オブジェクトを <code>XML</code> クラスのコンストラクタを使ってラップします。</p>
<pre class="source">
<span class="comment">// <code>XMLLoader</code> から DOM を構築し、<code>XML</code> クラスでラップします。</span>
XMLLoader loader = new XMLLoader();
loader.setValidation(true);
loader.setIgnoreComment(true);

XML xml = new XML(loader.load(new FileInputStream(new File("test.xml"))));
</pre>

<h2 id="traversal">DOM の検索<span class="sub"> - Traversal</span></h2>

<h3 id="find">要素の検索 <span class="sub"> - find</span></h3>
<p>要素の検索には  <code>find</code> メソッドを使います。<code>find</code> メソッドは、<code>XML</code> クラス、<code>Nodes</code> クラスの両方で利用できます。引数には、XPath 式を記述します。CSS セレクタとは異なり、<code>//</code> から始めないと子要素のみの検索になることに注意してください。</p>
<pre class="source">
<span class="comment">// ドキュメントから div 要素を探し、さらに href 属性をもつ a 子要素を検索します。</span>
xml.find("//div").find("a[@href]");
</pre>
<p>ネームペースに対して検索する場合は、プレフィックスを付与します。
プレフィックスは、原則としてロード時に指定したものを使用します（未指定の場合は、ドキュメントからネームペースを取得しますが、読み込んだ XML に依存してしまいますので、お勧めできません）。</p>
<pre class="source">
<span class="comment">// ネームスペースを指定して XML インスタンスを構築します。</span>
Map&lt;String, String&gt; namespaces = new HashMap&lt;String, String&gt;();
namespaces.put("h", "http://www.w3.org/1999/xhtml")
XML xml = XML.load(new File("test.xml"), namespaces);

<span class="comment">// ドキュメントから xhtml の div 要素を探し、さらに href 属性をもつ xhtml の a 子要素を検索します。</span>
<span class="comment">// 指定するプレフィックスは、ドキュメント内に実際に付与されたプレフィックスには依存しません。</span>
xml.find("//h:div").find("h:a[@href]");
</pre>

<h3 id="select">ノードの検索 <span class="sub"> - select</span></h3>
<p>XPath は、要素以外にもテキストノードや属性ノード、コメントノードなども対象にすることができます。
XMLIC では、それに対応して jQuery にはない <code>select</code> メソッドを追加しています。<code>select</code> メソッドは、<code>XML</code> クラス、<code>Nodes</code> クラスの両方で利用できます。引数には、XPath 式を記述します。属性値の設定／取得には <code>val</code> メソッドを使います。</p>
<pre class="source">
<span class="comment">// ドキュメントから最初の属性ノードを検索し、その値を取得します。</span>
xml.select("//attribute::node()[1]").val();
</pre>
<p>jQuery では <code>val</code> メソッドは、入力タグに対する値を取得するメソッドとして用意されていますが、 XMLIC では、<code>Node</code> クラスの
<code>get/setNodeValue()</code> に対するアクセッサとして機能します。</p>

<h3 id="xpath">XPath と CSS セレクタとの比較</h3>
<p>主要な XPath 式と CSS セレクタの対比表を次に示します。参考にしてください。</p>
<table class="table">
<colgroup>
<col style="width: 150px" />
<col style="width: 200px" />
<col style="width: 200px" />
<col />
</colgroup>
<thead>
<tr><th>対象</th><th>XPath</th><th>CSS セレクタ</th><th>備考</th></tr>
</thead>
<tbody>
<tr><td>すべての要素</td><td><code>//*</code></td><td><code>*</code></td><td></td></tr>
<tr><td>要素が一致</td><td><code>//element</code></td><td><code>element</code></td><td></td></tr>
<tr><td>子要素</td><td><code>//parent/child</code></td><td><code>parent &gt; child</code></td><td></td></tr>
<tr><td>子孫要素</td><td><code>//ancestor//descendant</code></td><td><code>ancestor descendant</code></td><td></td></tr>
<tr><td>属性がある</td><td><code>//*[@name]</code></td><td><code>[name]</code></td><td></td></tr>
<tr><td>属性が一致</td><td><code>//*[@name='value']</code></td><td><code>[name='value']</code></td><td></td></tr>
<tr><td>n番目の子要素</td><td><code>//*[n]</code></td><td><code>:nth-child(n)</code></td><td></td></tr>
<tr><td>最初の子要素</td><td><code>//*[first()]</code></td><td><code>:first-child</code></td><td></td></tr>
<tr><td>最後の子要素</td><td><code>//*[last()]</code></td><td><code>:last-child</code></td><td></td></tr>
<tr><td>OR 条件選択</td><td><code>expr | ... | expr</code></td><td><code>expr, ..., expr</code></td><td></td></tr>
</tbody>
</table>
<p>jQueryでは <code>#ID</code> の形でID指定を多用しますが、XMLではスキーマにID型が指定されない限り利用できないため、通常の属性同様 <code>//*[@id='ID']</code> と記述します
（XPath にも ID 構文は存在しますが、スキーマを使い検証を実施し DOM 内に ID 型であるという情報が設定されている場合に限り、<code>//*[id()='ID']</code> と書くことで検索が可能です）。</p>

<h3 id="children">子要素の取得<span class="sub"> - children</span></h3>
<p>子要素の取得には、<code>children</code> メソッドを使います。引数に XPathのフィルタ条件（角カッコの中）を記載することでフィルタリングが可能です。</p>
<pre class="source">
<span class="comment">// ドキュメントの中から <code>div</code> 要素を検索し、それらの要素に対する子要素の一覧を取得します。</span>
xml.find("//div").children();

<span class="comment">// ドキュメントの中から <code>div</code> 要素を検索し、span という名前を持つその子要素の一覧を取得します。</span>
xml.find("//div").children("local-name()='span'");
</pre>

<h3 id="parent">親要素の取得<span class="sub"> - parent, parents / parentsUntil, closest</span></h3>
<p>親要素の取得には、<code>parent</code> メソッドを使います。すべての親（＝先祖）要素を取得する場合は <code>parents</code> メソッドを使います。
引数に XPathのフィルタ条件（角カッコの中）を記載することでフィルタリングが可能です。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対する親要素を取得します。</span>
xml.find("//div").parent();

<span class="comment">// <code>div</code> 要素を検索し、それらの要素にすべての親要素を取得します。</span>
xml.find("//div").parents();

<span class="comment">// フィルタリングも可能です。</span>
xml.find("//div").parent("@class='test'");
xml.find("//div").parents("@class='test'");
</pre>
<p>条件に一致する親要素までを取得できる  <code>parentsUntil</code>、自分も含むすべての親要素をから最初に条件に一致した要素を取得できる <code>closest</code> 
も同様に用意されています。</p>
<pre class="source">
<span class="comment">//  <code>div</code> 要素を検索し、<code>class="test"</code> を持つ要素までの親要素を取得します。</span>
xml.find("//div").parentsUntil("@class='test'");

<span class="comment">//  <code>div</code> 要素の自分も含む上位要素の中から、最初に条件に一致する要素を取得します。</span>
xml.find("//div").closest("@class='test'");
</pre>

<h3 id="sibling">兄弟要素の取得<span class="sub"> - prev / prevUntil / prevAll, next / nextUntil / nextAll, siblings</span></h3>
<p>兄弟要素の取得には、前にある要素を取得する <code>prev</code> 系メソッド、後にある要素を取得する <code>next</code> 系メソッド、前後両方の要素を取得する
<code>siblings</code> メソッドがあります。</p>
<p><code>prev</code> 系メソッドには、直前を取得する同名メソッドの他に、前に位置する兄弟要素すべてを取得する <code>prevAll</code>、
条件に一致するまで前にさかのぼる <code>prevUntil</code> があります。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対する直前の要素の一覧を取得します。</span>
xml.find("//div").prev();

<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対して前にある要素すべての一覧を取得します。</span>
xml.find("//div").prevAll();

<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対して条件に一致するまで前にある要素を取得します。</span>
xml.find("//div").prevUntil("@class='test'");

<span class="comment">// フィルタリングも可能です。</span>
xml.find("//div").prev("@class='test'");
xml.find("//div").prevAll("@class='test'");
</pre>

<p><code>next</code> 系メソッドも同様に、直後を取得する同名メソッドの他に、後ろに位置する兄弟要素すべてを取得する <code>nextAll</code>、
条件に一致するまで後ろに進む <code>nextUntil</code> があります。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対する直後の要素の一覧を取得します。</span>
xml.find("//div").next();

<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対して後ろにある要素すべての一覧を取得します。</span>
xml.find("//div").nextAll();

<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対して条件に一致するまで後ろにある要素を取得します。</span>
xml.find("//div").nextUntil("@class='test'");

<span class="comment">// フィルタリングも可能です。</span>
xml.find("//div").next("@class='test'");
xml.find("//div").nextAll("@class='test'");
</pre>

<p><code>siblings</code>は、すべての兄弟要素を取得するメソッドで <code>prevAll</code> と <code>nextAll</code> を結合したような効果を持ちます。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対するすべての兄弟要素を取得します。</span>
xml.find("//div").siblings();

<span class="comment">// フィルタリングも可能です。</span>
xml.find("//div").siblings("@class='test'");
</pre>

<h3 id="contents">子ノードの取得<span class="sub"> - contents</span></h3>
<p>子要素を取得するには、<code>children</code> メソッドを使いますが、テキストノードなどは除外されます。テキストノードやコメントノードなどすべての子ノードを取得する場合には、
<code>contents</code> メソッドを使います。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対するすべての子ノードを取得します。</span>
xml.find("//div").contents();

<span class="comment">// フィルタリングも可能です。</span>
xml.find("//div").contents("first()");
</pre>

<h3 id="filter">取得結果の操作<span class="sub"> - filter, eq　/ first / last　/ slice</span></h3>
<p>取得結果をフィルタリングしたい場合は、<code>filter</code> メソッドを使います。<code>filter</code>メソッドには、XPath 
式によるフィルタと、内部クラスを用いた２種類が用意されています。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索した結果に対し属性でフィルタリングします。</span>
xml.find("//div").filter("@name='test'");

<span class="comment">// <code>div</code> 要素を検索した結果に対しメソッドを使って属性ででフィルタリングします。</span>
xml.find("//div").filter(new Acceptor() {
	public boolean accept(Node node) {
		return "test".equals(node.getAttributeNS(null, "name"));
	}
});
</pre>
<p>また、位置によるフィルタリングとして <code>eq</code>、<code>first</code>、<code>last</code>の３メソッドが、位置範囲に
対するフィルタとして <code>slice</code> が用意されています。なお、<code>first</code>、<code>last</code> メソッドは、
それぞれ <code>eq(0)</code>、<code>eq(-1)</code> のショートカットです。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索した結果の3番目を取得します。</span>
xml.find("//div").eq(3);

<span class="comment">// <code>div</code> 要素を検索した結果の2～4番目を取得します。</span>
xml.find("//div").slice(2, 4);
</pre>
<p>jQuery の <code>:first</code>、<code>:last</code> とは異なり、XMLIC には結果集合それ自体に対して
フィルタリングする XPath 式がないがめ、常に<code>first()</code>、<code>last()</code>を使う必要があることに注意して
ください。</p>

<h3 id="add">取得結果の結合<span class="sub"> - add, addBack</span></h3>
<p>取得結果に対し、別の検索結果を結合したい場合は、<code>add</code> メソッドを使います。一つ前の処理結果を現在の結果に結合したい場合は、
<code>addBack</code>　を使います。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索した結果に <code>p</code> 要素を検索した結果を結合します。なお、次の二つの表現は等価です。</span>
xml.find("//div").add("//p");
xml.find("//div").add(xml.find("//p"));

<span class="comment">// <code>div</code> 要素の子要素  <code>p</code> を検索した結果に 最初の <code>div</code> 要素の検索結果を結合します。フィルタリングも可能です。</span>
xml.find("//div").find("p").addBack();
xml.find("//div").find("p").addBack("@name='test'");
</pre>

<h3 id="add">取得結果の復元<span class="sub"> - end</span></h3>
<p>一つ前の取得結果に戻したい場合は、 <code>end</code> メソッドを使います。このメソッドを使うことでメソッド連結でも入れ子表現が可能になります。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索した結果に <code>p</code> 要素を検索した結果を結合した後、最初の検索結果を取得します。</span>
xml.find("//div")
  .find("p")
.end();
</pre>

<h2 id="#manipulation">DOM の操作<span class="sub"> - Manipulation</span></h2>

<h3 id="name">名前の操作</h3>
<h3 id="attr">属性の操作</h3>
<h3 id="text">テキスト／値の操作</h3>
<h3 id="is">要素の評価</h3>
<h3 id="append">要素の追加</h3>
<h3 id="replace">要素の置換</h3>
<h3 id="remove">要素の削除</h3>
<h3 id="remove">要素の複製</h3>
<h3 id="evaluate">ノードの評価</h3>
<h3 id="normalize">ノードの正規化</h3>

<h2 id="write">XML 文書の出力<span class="sub"> - Write</span></h2>

<p>XML 文書の出力も読み込み同様に２パターンが用意されています。通常は <code>XML</code> クラスの <code>writeTo</code> メソッドを使います。オプションは指定出来ませんが、通常の利用には十分でしょう。</p>
<pre class="source">
<span class="comment">// ファイルに  DOM の内容を出力します。</span>
xml.writeTo(new File("test.xml"));

<span class="comment">// <code>OutputStream</code> に  DOM の内容を出力します。クローズは自動的に行われます。</span>
xml.writeTo(new FileOutputStream("test.xml"));

<span class="comment">// <code>Writer</code> に DOM の内容を出力します。クローズは自動的に行われます。</span>
xml.writeTo(new OutputStreamWriter(new FileOutputStream("test.xml"), "Windows-31J"));
</pre>

<p>改行コードの変更などオプションの指定が必要な場合は、<code>XMLWriter</code> を使います。</p>
<pre class="source">
<span class="comment">// DOM を <code>XMLWrite</code> に渡しファイルに出力します。</span>
XMLWriter writer = new XMLWriter();
writer.setEncoding("EUC-JP");
writer.setLineSeparator("\r\n");
writer.setPrettyPrinting(true);

writer.writeTo(new FileOutputStream("test.xml"), xml.get());
</pre>

<h2 id="license">ライセンス</h2>
<p>XMLIC は、<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>下で配布します。</p>
<p><b>自分のライブラリへの組み込んでいただいたり、その際にパッケージ名の変更や処理の変更など行っていただいても何ら構いません。</b>ライセンスの範囲内でご自由にお使いください。</p>

<h2 id="report">バグ・要望の報告先</h2>
<p>バグや要望などは<a href="http://sourceforge.jp/projects/xmlic">XMLIC プロジェクトサイト</a>の<a href="http://sourceforge.jp/projects/xmlic/ticket/">チケット</a>に報告ください。</p>

<h2 id="releasenote">リリースノート</h2>

<h3>2013/7/16 version 0.8.0</h3>
<ul>
<li>XMLIC 最初のリリースとなります。元となる仕様が jQuery API ですので大きな変更は予定していませんが、1.0 までは不具合、要望など積極的に取り入れたいと思いますので、ご要望あれば是非。</li>
</ul>

</div>

<div class="footer">
Copyright (C) 2013 Hidekatsu Izuno All right reserved.
</div>
</body>
</html>