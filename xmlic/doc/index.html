<!doctype html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>XMLIC - jQuery like DOM traversal and manipulation API</title>
<link rel="stylesheet" href="css/common.css" />
<style>
.sourceforge { position: absolute; top: 5px; right: 10px; }
</style>
</head>
<body>
<div class="nav">
<h1 class="logo"><a href="#"><img src="img/xmlic.jpg" alt="XMLIC" width="115" height="34" /></a></h1>
<div class="bar">version 0.9.1</div>
<ul class="menu">
	<li><a href="#introduction">XMLICとは</a></li>
	<li><a href="#download">ダウンロード</a></li>
	<li><a href="#usage">基本的な使い方</a></li>
	<li><a href="#load">XML文書の読み込み</a></li>
	<li><a href="#traversal">DOMの検索</a>
		<ul>
			<li><a href="#find">要素の検索</a></li>
			<li><a href="#select">ノードの検索</a></li>
			<li><a href="#traverse">ノードの横断</a></li>
			<li><a href="#xpath">XPathとCSSセレクタとの比較</a></li>
			<li><a href="#children">子要素の取得</a></li>
			<li><a href="#parent">親要素の取得</a></li>
			<li><a href="#sibling">兄弟要素の取得</a></li>
			<li><a href="#contents">子ノードの取得</a></li>
			<li><a href="#filter">取得結果の操作</a></li>
			<li><a href="#add">取得結果の結合</a></li>
			<li><a href="#end">取得結果の復元</a></li>
			<li><a href="#each">取得結果の列挙</a></li>
		</ul>
	</li>
	<li><a href="#manipulation">DOMの操作</a>
		<ul>
			<li><a href="#name">名前の操作</a></li>
			<li><a href="#attr">属性の操作</a></li>
			<li><a href="#text">テキスト／値の操作</a></li>
			<li><a href="#is">要素の評価</a></li>
			<li><a href="#append">要素の追加</a></li>
			<li><a href="#replace">要素の置換</a></li>
			<li><a href="#wrap">要素のラッピング</a></li>
			<li><a href="#remove">要素の削除</a></li>
			<li><a href="#clone">要素の複製</a></li>
			<li><a href="#evaluate">ノードの評価</a></li>
			<li><a href="#normalize">ノードの正規化</a></li>
		</ul>
	</li>
	<li><a href="#write">XML文書の出力</a></li>
	<li>API リファレンス
		<ul>
			<li><a href="http://xmlic.sourceforge.jp/api/index.html">javadoc</a></li>
		</ul>
	</li>
	<li><a href="#license">ライセンス</a></li>
	<li><a href="#report">バグ・要望の報告先</a></li>
	<li><a href="#releasenote">リリースノート</a></li>
</ul>
</div>
<div class="header">
<h1><span class="title">XMLIC</span> <span class="sub">- jQuery like DOM traversal and manipulation API</span></h1>
<div class="sourceforge"><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=8657&type=1" width="96" height="31" border="0" alt="SourceForge.JP"></a></div>
<div class="bar">&nbsp;</div>
</div>
<div class="main">

<h2 id="introduction" style="margin-top: 0px;">XMLIC（ズムリック）とは</h2>
<p>jQuery ライクな DOM 操作を実現する Java 用 XML APIです。JDOM や XOM などと異なり、あくまで W3C 標準の DOM に対し検索、操作を行なうため、XSLT など他ライブラリとの高い相互運用性を実現出来ます。API は jQuery に似ていますが、XMLIC は XML の操作に特化しているため、次のような違いがあります。</p>
<ul>
<li>CSS セレクタの代わりに XPath を使用します。</li>
<li>複数ドキュメントを扱うことができます。入出力機能も用意されています。</li>
<li>XML名前空間を適切に扱うことができます。</li>
</ul>
<p>使い方は簡単です。jQuery 利用者ならば、すぐに使いはじめることができるでしょう。</p>
<pre class="source">
import net.arnx.xmlic.XML;

<span class="comment">// test.xml を読み込んで div タグに class="alert" という属性を設定します。</span>
XML.load(new File("test.xml"))
    .find("div")
    .attr("class", "alert");
</pre>

<h2 id="download">ダウンロード</h2>
<p><a href="http://sourceforge.jp/projects/xmlic">ダウンロードはこちらから</a>可能です。なお、XMLICのビルド/実行には、Java SE 6 以上が必要です。</p>
<script src="http://sourceforge.jp/projects/xmlic/releases/compact.js" type="text/javascript" charset="utf-8"></script>

<h2 id="usage">基本的な使い方</h2>
<p>jQuery の Traversal/Manipulation API をそのままの仕様で移植していますので同じように操作が可能です。大きく違う点は、<code>Document</code> の取り回しです。
jQuery が単一の <code>window.document</code> に対して　XMLIC は複数のドキュメントを扱う必要があります。このような処理のために<code>XML</code> クラスが用意されています（jQuery の <code>$</code> 関数に当たるものだと考えるとわかりやすいでしょう）。</p>
<ul>
<li>読み込みには、 <code>XML</code> クラスの <code>load()</code> スタティックメソッドを使います。</li>
<li>読み込んだ  <code>XML</code> インスタンスに対し、<code>find()</code> メソッドで <code>Nodes</code> インスタンスを取得し操作します（<code>Nodes</code> インスタンスは <code>jQuery</code> オブジェクトに当たるものだと考えるとよいでしょう）。</li>
<li><code>XML</code> インスタンス は、<code>Nodes</code> インスタンスの <code>getOwner()</code> メソッドを通じて取得できます。</li>
<li>書き込みは、 <code>XML</code> インスタンスの <code>writeTo()</code> メソッドを使います。</li>
</ul>
<p>XPath は  XSLT 1.0 パターンとして判定されます。そのため、子孫要素の <code>div</code> を捜すために <code>find(".//div")</code> のように記述する必要はなく、 
<code>find("div")</code> と書くことができます。</p>
<p>なお、現状は、HTML 向けの機能（<code>addClass</code>、<code>removeClass</code>、<code>val</code>　や HTML 形式での出力）は実装されておりません（仕様に不整合があるわけではないので、実装することは可能ですが、優先順位の問題から行なっていません）。</p>

<h2 id="load">XML 文書の読み込み <span class="sub">- Load</span></h2>

<p>XML 文書の読み込みには、２パターンが用意されています。通常は <code>XML</code> クラスの <code>load</code> スタティックメソッドを使います。オプションは指定出来ませんが、通常の利用では困ることはないでしょう。</p>
<pre class="source">
<span class="comment">// ファイルから <code>XML</code> クラスのインスタンスを取得します。</span>
XML xml = XML.load(new File("test.xml"));

<span class="comment">// <code>InputStream</code> から <code>XML</code> クラスのインスタンスを取得します。クローズは自動的に行われます。</span>
XML xml = XML.load(new FileInputStream("test.xml"));

<span class="comment">// <code>Reader</code> から <code>XML</code> クラスのインスタンスを取得します。クローズは自動的に行われます。</span>
XML xml = XML.load(new FileReader("test.xml"));

<span class="comment">// <code>URI</code> から <code>XML</code> クラスのインスタンスを取得します。</span>
XML xml = XML.load(new URI("http://..."));
</pre>

<p>検証を行なう必要があるなど、オプションの指定が必要な場合は、<code>XMLLoader</code> （あるいは <code>DocumentBuilder</code> などを通じて）構築した Document 
オブジェクトを <code>XML</code> クラスのコンストラクタを使ってラップします。</p>
<pre class="source">
<span class="comment">// <code>XMLLoader</code> から DOM を構築し、<code>XML</code> クラスでラップします。</span>
XMLLoader loader = new XMLLoader();
loader.setValidation(true);
loader.setIgnoringComments(true);
Document doc = loader.load(new FileInputStream(new File("test.xml")));

XML xml = new XML(doc);
</pre>

<p>外部にあるドキュメントではなく、部分的な XML をインラインで読み込む場合には、<code>parse</code> メソッドを使います。すでに DOM ノード値して構築されている場合は、 <code>Nodes</code>　コンストラクタを使って取り込みます。</p>
<pre class="source">
<span class="comment">// 部分的な XML をインラインで読み込みます。</span>
Nodes nodes = xml.parse("&lt;div&gt;部分的なXML&lt;/div&gt;&lt;div&gt;部分的なXML&lt;/div&gt;");

<span class="comment">// 構築済みのノードを <code>Nodes</code> オブジェクトに変換します。</span>
Node node = ...;
Nodes nodes = new Nodes(xml, node);

NodeList list = ...;
Nodes nodes = new Nodes(xml, list);
</pre>

<h2 id="traversal">DOM の検索<span class="sub"> - Traversal</span></h2>

<h3 id="find">要素の検索 <span class="sub"> - find</span></h3>
<p>要素の検索には  <code>find</code> メソッドを使います。<code>find</code> メソッドは、<code>XML</code> クラス、<code>Nodes</code> クラスの両方で利用できます。引数には、XPath 式を記述します。</p>
<pre class="source">
<span class="comment">// ドキュメントから div 要素を探し、さらに href 属性をもつ a 子要素を検索します。</span>
xml.find("div").find("a[@href]");
</pre>
<p>名前空間に対して検索する場合は、プレフィックスを付与します。デフォルトでルート要素に付与された名前空間情報は収集しますが、読み込んだドキュメントに依存するため、明示的に指定する方がよいでしょう。</p>
<pre class="source">
<span class="comment">// XML インスタンスを構築し、利用する名前空間を指定します。</span>
XML xml = XML.load(new File("test.xml"));
xml.addNamespaceMapping("h", "http://www.w3.org/1999/xhtml");

<span class="comment">// ドキュメントから xhtml の div 要素を探し、さらに href 属性をもつ xhtml の a 子要素を検索します。</span>
<span class="comment">// 指定するプレフィックスは、ドキュメント内に実際に付与されたプレフィックスには依存しません。</span>
xml.find("h:div").find("h:a[@href]");
</pre>

<h3 id="select">ノードの検索 <span class="sub"> - select</span></h3>
<p>XPath は、要素以外にもテキストノードや属性ノード、コメントノードなども対象にすることができます。
XMLIC では、それに対応して jQuery にはない <code>select</code> メソッドを追加しています。<code>select</code> メソッドは、<code>XML</code> クラス、<code>Nodes</code> クラスの両方で利用できます。引数には、XPath 式を記述します。属性値の設定／取得には <code>val</code> メソッドを使います。</p>
<pre class="source">
<span class="comment">// ドキュメントから最初の属性ノードを検索し、その値を取得します。</span>
xml.select("attribute::node()[1]").val();
</pre>
<p>jQuery では <code>val</code> メソッドは、入力タグに対する値を取得するメソッドとして用意されていますが、 XMLIC では、<code>Node</code> クラスの
<code>get/setNodeValue()</code> に対するアクセッサとして機能します。</p>

<h3 id="traverse">ノードの横断 <span class="sub"> - traverse</span></h3>
<p>DOM Level2 では、ノードを横断し列挙する機能が追加されましたが、XMLIC　にも対応する機能が用意されています。</p>
<pre class="source">
<span class="comment">// ドキュメントからすべての要素にマッチするノードを順番に訪問します。</span>
xml.traverse("*", new Visitor&lt;Nodes&gt;() {
  public void visit(Nodes current, Status status) {
  	System.out.println(current.name());
  }
});

<span class="comment">// 第2引数を true にすることで逆順にたどることもできます</span>
xml.traverse("*", true, new Visitor&lt;Nodes&gt;() {
  public void visit(Nodes current, Status status) {
  	System.out.println(current.name());
  }
});
</pre>

<h3 id="xpath">XPath と CSS セレクタとの比較</h3>
<p>主要な XPath 式と CSS セレクタの対比表を次に示します。参考にしてください。</p>
<table class="table">
<colgroup>
<col style="width: 150px" />
<col style="width: 200px" />
<col style="width: 200px" />
<col />
</colgroup>
<thead>
<tr><th>対象</th><th>XPath</th><th>CSS セレクタ</th><th>備考</th></tr>
</thead>
<tbody>
<tr><td>すべての要素</td><td><code>*</code></td><td><code>*</code></td><td></td></tr>
<tr><td>要素が一致</td><td><code>element</code></td><td><code>element</code></td><td></td></tr>
<tr><td>子要素</td><td><code>parent/child</code></td><td><code>parent &gt; child</code></td><td></td></tr>
<tr><td>子孫要素</td><td><code>ancestor//descendant</code></td><td><code>ancestor descendant</code></td><td></td></tr>
<tr><td>属性がある</td><td><code>*[@name]</code></td><td><code>[name]</code></td><td></td></tr>
<tr><td>属性が一致</td><td><code>*[@name='value']</code>　あるいは <code>@name='value'</code></td><td><code>[name='value']</code></td><td></td></tr>
<tr><td>n番目の子要素</td><td><code>*[n]</code> あるいは <code>*[position()=n]</code></td><td><code>:nth-child(n)</code></td><td></td></tr>
<tr><td>最初の子要素</td><td><code>*[first()]</code></td><td><code>:first-child</code></td><td></td></tr>
<tr><td>最後の子要素</td><td><code>*[last()]</code></td><td><code>:last-child</code></td><td></td></tr>
<tr><td>OR 条件選択</td><td><code>expr | ... | expr</code></td><td><code>expr, ..., expr</code></td><td></td></tr>
</tbody>
</table>
<p>jQueryでは <code>#ID</code> の形でID指定を多用しますが、XMLではスキーマにID型が指定されない限り利用できないため、通常の属性同様 <code>@id='ID'</code> と記述します
（XPath にも ID 構文は存在しますが、スキーマを使い検証を実施し DOM 内に ID 型であるという情報が設定されている場合に限り、<code>id()='ID'</code> と書くことで検索が可能です）。</p>

<h3 id="children">子要素の取得<span class="sub"> - children</span></h3>
<p>子要素の取得には、<code>children</code> メソッドを使います。引数に XPathのフィルタ条件（角カッコの中）を記載することでフィルタリングが可能です。</p>
<pre class="source">
<span class="comment">// ドキュメントの中から <code>div</code> 要素を検索し、それらの要素に対する子要素の一覧を取得します。</span>
xml.find("div").children();

<span class="comment">// ドキュメントの中から <code>div</code> 要素を検索し、span という名前を持つその子要素の一覧を取得します。</span>
xml.find("div").children("span");
</pre>

<h3 id="parent">親要素の取得<span class="sub"> - parent, parents / parentsUntil, closest</span></h3>
<p>親要素の取得には、<code>parent</code> メソッドを使います。すべての親（＝先祖）要素を取得する場合は <code>parents</code> メソッドを使います。
引数に XPathのフィルタ条件（角カッコの中）を記載することでフィルタリングが可能です。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対する親要素を取得します。</span>
xml.find("div").parent();

<span class="comment">// <code>div</code> 要素を検索し、それらの要素にすべての親要素を取得します。</span>
xml.find("div").parents();

<span class="comment">// フィルタリングも可能です。</span>
xml.find("div").parent("@class='test'");
xml.find("div").parents("@class='test'");
</pre>
<p>条件に一致する親要素までを取得できる  <code>parentsUntil</code>、自分も含むすべての親要素をから最初に条件に一致した要素を取得できる <code>closest</code> 
も同様に用意されています。</p>
<pre class="source">
<span class="comment">//  <code>div</code> 要素を検索し、<code>class="test"</code> を持つ要素までの親要素を取得します。</span>
xml.find("div").parentsUntil("@class='test'");

<span class="comment">//  <code>div</code> 要素の自分も含む上位要素の中から、最初に条件に一致する要素を取得します。</span>
xml.find("div").closest("@class='test'");
</pre>

<h3 id="sibling">兄弟要素の取得<span class="sub"> - prev / prevUntil / prevAll, next / nextUntil / nextAll, siblings</span></h3>
<p>兄弟要素の取得には、前にある要素を取得する <code>prev</code> 系メソッド、後にある要素を取得する <code>next</code> 系メソッド、前後両方の要素を取得する
<code>siblings</code> メソッドがあります。</p>
<p><code>prev</code> 系メソッドには、直前を取得する同名メソッドの他に、前に位置する兄弟要素すべてを取得する <code>prevAll</code>、
条件に一致するまで前にさかのぼる <code>prevUntil</code> があります。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対する直前の要素の一覧を取得します。</span>
xml.find("div").prev();

<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対して前にある要素すべての一覧を取得します。</span>
xml.find("div").prevAll();

<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対して条件に一致するまで前にある要素を取得します。</span>
xml.find("div").prevUntil("@class='test'");

<span class="comment">// フィルタリングも可能です。</span>
xml.find("div").prev("@class='test'");
xml.find("div").prevAll("@class='test'");
</pre>

<p><code>next</code> 系メソッドも同様に、直後を取得する同名メソッドの他に、後ろに位置する兄弟要素すべてを取得する <code>nextAll</code>、
条件に一致するまで後ろに進む <code>nextUntil</code> があります。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対する直後の要素の一覧を取得します。</span>
xml.find("div").next();

<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対して後ろにある要素すべての一覧を取得します。</span>
xml.find("div").nextAll();

<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対して条件に一致するまで後ろにある要素を取得します。</span>
xml.find("div").nextUntil("@class='test'");

<span class="comment">// フィルタリングも可能です。</span>
xml.find("div").next("@class='test'");
xml.find("div").nextAll("@class='test'");
</pre>

<p><code>siblings</code>は、すべての兄弟要素を取得するメソッドで <code>prevAll</code> と <code>nextAll</code> を結合したような効果を持ちます。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対するすべての兄弟要素を取得します。</span>
xml.find("div").siblings();

<span class="comment">// フィルタリングも可能です。</span>
xml.find("div").siblings("@class='test'");
</pre>

<h3 id="contents">子ノードの取得<span class="sub"> - contents</span></h3>
<p>子要素を取得するには、<code>children</code> メソッドを使いますが、テキストノードなどは除外されます。テキストノードやコメントノードなどすべての子ノードを取得する場合には、
<code>contents</code> メソッドを使います。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索し、それらの要素に対するすべての子ノードを取得します。</span>
xml.find("div").contents();

<span class="comment">// フィルタリングも可能です。</span>
xml.find("div").contents("first()");
</pre>

<h3 id="filter">取得結果の操作<span class="sub"> - filter / not, eq　/ first / last　/ slice</span></h3>
<p>取得結果をフィルタリングしたい場合は、<code>filter</code> メソッドを使います。<code>filter</code>メソッドには、XPath 
式によるフィルタと、内部クラスを用いた２種類が用意されています。<code>not</code> メソッドは、<code>filter</code> 
とは逆に条件にマッチしないものだけを残します。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索した結果に対し属性でフィルタリングします。</span>
xml.find("div").filter("@name='test'");

<span class="comment">// <code>div</code> 要素を検索した結果に対し条件にマッチしないものだけ残します。</span>
xml.find("div").not("@name='test'");

<span class="comment">// <code>div</code> 要素を検索した結果に対しメソッドを使って属性ででフィルタリングします。</span>
xml.find("div").filter(new Visitor() {
	public boolean visit(Node node) {
		return "test".equals(node.getAttributeNS(null, "name"));
	}
});
</pre>
<p>また、位置によるフィルタリングとして <code>eq</code>、<code>first</code>、<code>last</code>の３メソッドが、位置範囲に
対するフィルタとして <code>slice</code> が用意されています。なお、<code>first</code>、<code>last</code> メソッドは、
それぞれ <code>eq(0)</code>、<code>eq(-1)</code> のショートカットです。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索した結果の3番目を取得します。</span>
xml.find("div").eq(3);

<span class="comment">// <code>div</code> 要素を検索した結果の2～4番目を取得します。</span>
xml.find("div").slice(2, 4);
</pre>
<p>jQuery の <code>:first</code>、<code>:last</code> とは異なり、XMLIC には結果集合それ自体に対して
フィルタリングする XPath 式がないがめ、常に<code>first()</code>、<code>last()</code>を使う必要があることに注意して
ください。</p>

<h3 id="add">取得結果の結合<span class="sub"> - add, addBack</span></h3>
<p>取得結果に対し、別の検索結果を結合したい場合は、<code>add</code> メソッドを使います。一つ前の処理結果を現在の結果に結合したい場合は、
<code>addBack</code>　を使います。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索した結果に <code>p</code> 要素を検索した結果を結合します。なお、次の二つの表現は等価です。</span>
xml.find("div").add("p");
xml.find("div").add(xml.find("p"));

<span class="comment">// <code>div</code> 要素の子要素  <code>p</code> を検索した結果に 最初の <code>div</code> 要素の検索結果を結合します。フィルタリングも可能です。</span>
xml.find("div").find("p").addBack();
xml.find("div").find("p").addBack("@name='test'");
</pre>

<h3 id="end">取得結果の復元<span class="sub"> - end</span></h3>
<p>一つ前の取得結果に戻したい場合は、 <code>end</code> メソッドを使います。このメソッドを使うことでメソッド連結でも入れ子表現が可能になります。</p>
<pre class="source">
<span class="comment">// <code>div</code> 要素を検索した結果に <code>p</code> 要素を検索した結果を結合した後、最初の検索結果を取得します。</span>
xml.find("div")
  .find("p")
.end();
</pre>

<h3 id="each">取得結果の列挙<span class="sub"> - each</span></h3>
<p><code>Nodes</code> クラスは、<code>ArrayList&lt;Node&gt;</code> を継承しているため、通常のリストと同様、<code>for</code> 
文による列挙が可能です。</p>
<pre class="source">
<span class="comment">// 取得結果を列挙します。</span>
for (Node node : xml.find("div")) {
  Nodes current = new Nodes(xml, node);
  System.out.println(current.name());
}
</pre>
<p>jQuery 同様に <code>each</code> メソッドによる列挙も可能です。ただし、 jQuery とはシンタックスが異なる点に注意が必要です。</p>
<pre class="source">
<span class="comment">// 取得結果を列挙します。</span>
xml.find("div").each(new Visitor&lt;Nodes&gt;() {
  public void visit(Nodes current, Status status) {
    System.out.println("" + status.getIndex() + ": " + current.name());
  }
});

<span class="comment">// 第一引数に true を設定することで、逆順の列挙も可能です。</span>
xml.find("div").each(true, new Visitor&lt;Nodes&gt;() {
  public void visit(Nodes current, Status status) {
    System.out.println("" + status.getIndex() + ": " + current.name());
  }
});

<span class="comment">// 途中で break したい場合は <code>cancel</code> メソッドを使ってください。キャンセル例外が発生して処理を中断します。</span>
xml.find("div").each(new Visitor&lt;Nodes&gt;() {
  public void visit(Nodes current, Status status) {
    if (status.getIndex() == 3) status.cancel();
    System.out.println("" + status.getIndex() + ": " + current.name());
  }
});
</pre>

<h2 id="manipulation">DOM の操作<span class="sub"> - Manipulation</span></h2>

<h3 id="name">名前の操作<span class="sub"> - name, namespace, prefix, localName</span></h3>
<p>XML と HTML の大きな違いとして名前空間のサポートがあります。仕様としては自然なものですが XML の利用において最大の難物とも言えます。
まず、XML における名前の概念を整理すると次のようになります。なお、属性については、プレフィックスを付けない場合、名前空間はデフォルト名前空間
ではなく、要素の名前空間に属します。</p>

<table class="table">
<colgroup>
<col style="width: 200px" />
<col style="width: 300px" />
</colgroup>
<thead>
<tr><th>概念</th><th>説明</th><th>例</th></tr>
</thead>
<tbody>
<tr><td>名前空間(Namespace URI)</td><td>タグセットの仕様を表す URI</td><td>http://www.w3.org/1999/xhtml</td></tr>
<tr><td>プレフィックス(Prefix)</td><td>文書中での名前空間に対する短縮名</td><td>任意（hなど）</td></tr>
<tr><td>ローカル名(Local Name)</td><td>タグの要素や属性の名前</td><td>div、span など</td></tr>
<tr><td>修飾された名前（QName）</td><td>プレフィックスで修飾されたローカル名</td><td>h:div、h:span など</td></tr>
</tbody>
</table>

<p>名前空間導入以前の XML における名前やいわゆる タグ名（<code>tagName</code>）は、デフォルト名前空間で修飾された名前として扱われます。</p>
<p>jQuery には名前の操作機能がありませんが、XMLIC では、名前空間、プレフィックス、ローカル名、修飾された名前それぞれに対し 
<code>namespace</code>、<code>prefix</code>、<code>localName</code>、<code>name</code>
メソッドでアクセスすることができます（複数のノードが含まれる場合は、先頭ノードの情報が返されます）。</p>
<pre class="source">
Nodes nodes = xml.parse("&lt;h:div xmlns:h=\"http://www.w3.org/1999/xhtml\"&gt;テスト&lt;/h:div&gt;");
nodes.namespace(); <span class="comment">// http://www.w3.org/1999/xhtml</span>
nodes.prefix(); <span class="comment">// h</span>
nodes.localName(); <span class="comment">// div</span>
nodes.name(); <span class="comment">// h:div</span>
</pre>
<p>変更する場合も、引数に値を設定するだけです。</p>
<pre class="source">
Nodes nodes = xml.parse("&lt;h:div xmlns:h=\"http://www.w3.org/1999/xhtml\"&gt;テスト&lt;/h:div&gt;");
<span class="comment">// プレフィックスは、文書中直近に指定されているものになります。存在しないときのみ、引数で指定したプレフィックスとなります。</span>
nodes.namespace("http://www.w3.org/2000/svg");　<span class="comment">// デフォルトに戻す場合は、<code>null</code> を設定します。</span>
nodes.prefix("svg"); <span class="comment">// プレフィックスのみを変更します（名前空間は変わりません）</span>
nodes.localName("span"); <span class="comment">// ローカル名のみを変更します（名前空間は変わりません）</span>

<span class="comment">// XML 構築時に設定したプレフィクスで指定します。実際のプレフィックスは、文書中直近に指定されているものになります。</span>
<span class="comment">// 存在しないときのみ、引数で指定したプレフィックスとなります。</span>
nodes.name("svg:span"); <span class="comment">// svg　に紐づく名前空間と span というローカル名に変更されます。</span>
</pre>

<p>名前空間については <code>removeNamespace</code> メソッドを使うことで削除することも可能です。</p>
<pre class="source">
Nodes nodes = xml.parse("&lt;h:div xmlns:h=\"http://www.w3.org/1999/xhtml\"&gt;テスト&lt;/h:div&gt;");
<span class="comment">// ネームスペースを削除します。</span>
nodes.removeNamespace();

<span class="comment">// 特定のネームスペースだけを削除することもできます。</span>
nodes.removeNamespace("http://www.w3.org/1999/xhtml");
</pre>

<h3 id="attr">属性の操作</h3>
<p>属性の操作は、<code>attr</code> メソッドを通じて行います。このメソッドも、名前同様に名前空間を考慮して操作することが可能です。</p>
<pre class="source">
nodes.attr("name"); <span class="comment">// 属性の値を取得します。</span>
nodes.attr("name", "1") <span class="comment">// 属性の値を設定します。</span>

<span class="comment">// 名前空間の取り扱いも可能です。XML 構築時に設定したプレフィクスで指定します。</span>
nodes.attr("http:name"); <span class="comment">// 名前空間付きの属性の値を取得します。</span>

<span class="comment">// XML 構築時に設定したプレフィクスで指定します。属性が追加される場合、実際のプレフィックスは、文書中直近に指定されているものになります。</span>
<span class="comment">// 存在しないときのみ、引数で指定したプレフィックスとなります。</span>
nodes.attr("http:name", "1") <span class="comment">// 名前空間を使って、属性を設定します。</span>
</pre>

<h3 id="text">テキスト／値の操作</h3>
<p>要素の子要素となっているテキストの操作には、<code>text</code> メソッドを使用します。</p>
<pre class="source">
<span class="comment">// 子ノード（以下）に含まれるテキストを結合して返されます。</span>
nodes.text();

<span class="comment">// 子ノードをテキストで置換します。</span>
nodes.text("text");
</pre>
<p>XPath では、要素以外のノードについても検索が可能なため、属性やコメントなど要素以外のノード値を操作する方法が用意されています。
具体的には <code>val</code> メソッドを使います。jQuery にも <code>val</code> メソッドがありますが、異なる動作をしますので
注意してください（将来的には、input など同名の要素に対して同じ動作を実装することも検討しています。現在は要素に対しては何の動作もしません）。</p>
<pre class="source">
<span class="comment">// <code>div</code>　要素以下の最初のノードの値を取得します。</span>
xml.find("div").contents().val();

<span class="comment">// <code>div</code>　要素以下の各種ノードの値を設定します。</span>
xml.find("div").contents().val("text");
</pre>

<h3 id="is">要素の評価<span class="sub"> - is, index</span></h3>
<p>要素が条件に一致するか調べたい場合には、<code>is</code> メソッドを使います。条件に一致するインデックス番号を取得したい場合には、<code>index</code>メソッドを使います。</p>
<pre class="source">
<span class="comment">// すべての <code>div</code> 要素に属性 <code>name="test"</code>が存在する場合 true になります。</span>
boolean result = xml.find("div").is("@name='test'");

<span class="comment">// <code>div</code> で最初に条件が一致したインデックス番号を返します。 見つからない場合は -1 を返します。</span>
int index = xml.find("div").index("@name='test'");

<span class="comment">// フィルタの代わりに、<code>Node</code> を指定することもできます。</span>
Node node = xml.find('div').first().get(0);
boolean result = xml.find("div").is(node);
int index = xml.find("div").index(node);
</pre>

<h3 id="append">要素の追加<span class="sub"> - prepend / prependTo, append / appendTo, before / insertBefore, after / insertAfter</span></h3>
<p>要素を追加したい場合は、<code>prepend</code>系、<code>append系</code>、<code>before</code>系、<code>after</code> 系の各メソッドを使います。
これらのメソッドは、それぞれ挿入位置が違うだけで、同じような使い方ができます。挿入位置の違いを次に示します。</p>
<div style="border: 1px solid black; padding: 1px 3px;">
親要素
<div style="border: 1px dashed green; background-color: #90ee90; margin: 10px; padding: 1px 3px;">before</div>
<div style="border: 1px solid blue; margin: 10px; padding: 1px 3px;">
要素
<div style="border: 1px dashed green; background-color: #90ee90; margin: 10px; padding: 1px 3px;">prepend</div>
<div style="border: 1px solid black; margin: 10px; padding: 1px 3px;">子要素…</div>
<div style="border: 1px dashed green; background-color: #90ee90; margin: 10px; padding: 1px 3px;">append</div>
</div>
<div style="border: 1px dashed green; background-color: #90ee90; margin: 10px; padding: 1px 3px;">after</div>
</div>
<p><code>prepend</code>、<code>append</code>、<code>before</code>、<code>after</code> と 
<code>prependTo</code>、<code>appendTo</code>、<code>insertBefore</code>、<code>insertAfter</code> 
の違いは、前者がオブジェクトの要素群に引数で指定した要素群を加えるのに対し、後者は、引数で指定した要素群にオブジェクトの要素群を加える点にあります（対象が逆になる）。</p>
<pre class="source">
<span class="comment">// すべての <code>div</code> 要素に指定した要素を追加します。</span>
xml.find("div").prepend("&lt;span&gt;最初の子要素として追加！&lt;/span&gt;");
xml.find("div").append("&lt;span&gt;最後の子要素として追加！&lt;/span&gt;");
xml.find("div").before("&lt;span&gt;直前の要素として追加！&lt;/span&gt;");
xml.find("div").after("&lt;span&gt;直後の要素として追加！&lt;/span&gt;");

<span class="comment">// 同じ結果になりますが記述が逆転します。</span>
xml.parse("&lt;span&gt;最初の子要素として追加！&lt;/span&gt;").prependTo("div");
xml.parse("&lt;span&gt;最後の子要素として追加！&lt;/span&gt;").appendTo("div");
xml.parse("&lt;span&gt;直前の要素として追加！&lt;/span&gt;").insertBefore("div");
xml.parse("&lt;span&gt;直後の要素として追加！&lt;/span&gt;").insertAfter("div");
</pre>

<h3 id="replace">要素の置換<span class="sub"> - replaceWith / replaceAll</span></h3>
<p>要素の置換には、<code>replaceWith</code> メソッドと <code>replaceAll</code> メソッドを使います。ふたつのメソッドの違いは、要素の追加と同様に置換対象と置換内容の記述位置だけです。</p>
<pre class="source">
<span class="comment">// すべての <code>div</code> 要素を指定した要素で置換します。</span>
xml.find("div").replaceWith("&lt;span&gt;最初の子要素として追加！&lt;/span&gt;");

<span class="comment">// 同じ結果になりますが記述が逆転します。</span>
xml.parse("&lt;span&gt;最初の子要素として追加！&lt;/span&gt;").replaceAll("//div");
</pre>

<h3 id="replace">要素のラッピング<span class="sub"> - wrap / wrapInner / wrapAll / unwrap</span></h3>
<p>要素のラッピングには、<code>wrap</code> 系メソッドを使います。<code>wrap</code> は要素自身を、<code>wrapInner</code> は要素の内側をラッピングします。
<code>unwrap</code> は <code>wrap</code> とは反対にラッピングを解除し、子要素で置換します。</p>
<pre class="source">
<span class="comment">// すべての <code>div</code> 要素を指定した要素でラップします。</span>
xml.find("div").wrap("&lt;div class=".wrap"&gt;&lt;&gt;"); <span class="comment">// &gt;&lt;の間に要素が挿入されます。</span>
xml.find("div").unwrap(); <span class="comment">// すべての <code>div</code> 要素のラッピングを解除します。</span>

<span class="comment">// すべての <code>div</code> 要素の内側を指定した要素でラップします。</span>
xml.find("div").wrapInner("&lt;div class=".wrap"&gt;&lt;&gt;");
</pre>
<p><code>wrapAll</code> は、対象となる要素の最初の位置に対象のすべての要素を包み込むようにラッピングします。</p>
<pre class="source">
<span class="comment">// 最初の <code>div</code> 要素の位置にすべての <code>div</code> 要素がラッピングされるように移動されます。</span>
xml.find("div").wrapInner("&lt;div class=".wrap"&gt;&lt;&gt;");
</pre>

<h3 id="remove">要素の削除<span class="sub"> - remove, empty</span></h3>
<p>要素を削除するメソッドとしては、要素自身を含めて削除する <code>remove</code> メソッドと要素の内側を削除する <code>empty</code> メソッドがあります。</p>
<pre class="source">
<span class="comment">// すべての <code>div</code> 要素を削除します。</span>
xml.find("div").remove();
xml.find("div").remove("span"); <span class="comment">// マッチした要素だけを削除することも可能です。</span>

<span class="comment">// すべての <code>div</code> 要素を空（＝内側を削除）にします。</span>
xml.find("div").empty();
</pre>

<h3 id="clone">ノードの複製<span class="sub"> - clone</span></h3>
<p>ノードを複製したい場合は、<code>clone</code> メソッドを使用します。</p>
<pre class="source">
Nodes clone = xml.find("div").clone();
</pre>

<h3 id="evaluate">ノードの評価<span class="sub"> - evaluate</span></h3>
<p>XPath では、ノードの選択の他に文字列/数値/真偽値の結果を返す場合があります。XMLIC には、そのような場合にも対応できるように、<code>evaluate</code> 
という汎用の XPath 評価メソッドを用意しています。引数には、 xpath と戻り値の型を指定します。型には、<code>Nodes</code>、<code>NodeList</code>、
<code>Node</code>、<code>String</code>、<code>Boolean</code> / <code>boolean</code>、各種数値型（<code>Number</code>のサブクラス）
を指定することができます。 </p>
<pre class="source">
if (nodes.evaluate("self::node()[@name='test']", boolean.class)) {
  <span class="comment">// マッチした！</span>
}
</pre>

<h3 id="normalize">ノードの正規化</h3>
<p><code>normalize</code> メソッドは、ノードの正規化を行います。具体的には、子要素より下にあるテキストノードを結合してひとつのノードにまとめます。これは、<code>Node</code> クラスの 
<code>normalize</code> の動作と同じですが、XMLIC ではこの動作に加え、不用な名前空間宣言の除去も行います。</p>
<pre class="source">
nodes.normalize();
</pre>

<h2 id="write">XML 文書の出力<span class="sub"> - Write</span></h2>

<p>XML 文書の出力も読み込み同様に２パターンが用意されています。通常は <code>XML</code> クラスの <code>writeTo</code> メソッドを使います。オプションは指定出来ませんが、通常の利用には十分でしょう。</p>
<pre class="source">
<span class="comment">// ファイルに  DOM の内容を出力します。</span>
xml.writeTo(new File("test.xml"));

<span class="comment">// <code>OutputStream</code> に  DOM の内容を出力します。クローズは自動的に行われます。</span>
xml.writeTo(new FileOutputStream("test.xml"));

<span class="comment">// <code>Writer</code> に DOM の内容を出力します。クローズは自動的に行われます。</span>
xml.writeTo(new OutputStreamWriter(new FileOutputStream("test.xml"), "Windows-31J"));
</pre>

<p>改行コードの変更などオプションの指定が必要な場合は、<code>XMLWriter</code> を使います。</p>
<pre class="source">
<span class="comment">// DOM を <code>XMLWrite</code> に渡しファイルに出力します。</span>
XMLWriter writer = new XMLWriter();
writer.setEncoding("EUC-JP");
writer.setLineSeparator("\r\n");
writer.setPrettyPrinting(true);

writer.writeTo(new FileOutputStream("test.xml"), xml.getDocument());
</pre>

<p>部分的な XML を出力したい場合は、<code>toString</code> でも取得出来ます。</p>

<h2 id="maven">Mavenリポジトリ</h2> 
<p>XMLIC は、0.9.1 以降 Maven Central Repository に登録されるようになりました。groupId、artifactIdは次の通りです。</p>
<pre class="source">
&lt;groupId&gt;net.arnx&lt;/groupId&gt;
&lt;artifactId&gt;xmlic&lt;/artifactId&gt;
</pre>

<h2 id="license">ライセンス</h2>
<p>XMLIC は、<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>下で配布します。</p>
<p><b>自分のライブラリへの組み込んでいただいたり、その際にパッケージ名の変更や処理の変更など行っていただいても何ら構いません。</b>ライセンスの範囲内でご自由にお使いください。</p>
<p>なお、 XMLIC は <a href="http://jaxen.codehaus.org/">jaxen</a> をパッケージを変更し同梱しています。その部分に関しては jaxen のライセンスに従ってください（Apache ライセンスに準じた緩いライセンスとなっていますので、特別な考慮は必要はありません）。</p>

<h2 id="report">バグ・要望の報告先</h2>
<p>バグや要望などは<a href="http://sourceforge.jp/projects/xmlic">XMLIC プロジェクトサイト</a>の<a href="http://sourceforge.jp/projects/xmlic/ticket/">チケット</a>に報告ください。</p>

<h2 id="releasenote">リリースノート</h2>

<h3>2013/8/XX version 0.9.2</h3>
<ul>
<li>ロード時の名前空間走査処理をルートノードだけに限定しました。</li>
<li>デフォルト名前空間が指定された場合の XPath 式の取り扱いを XSLT2.0 の xpath-default-namespace 属性設定時に合わせました。</li>
<li>StatusImpl を internal パッケージに移動しました。</li>
</ul>

<h3>2013/8/17 version 0.9.1</h3>
<ul>
<li>each、filter など繰り返し処理の引数インターフェイスを Java で利用しやすいように見直しました。</li>
<li>DOM2 Traversal API に対応した traverse メソッドを追加しました。</li>
</ul>

<h3>2013/8/8 version 0.9.0</h3>
<ul>
<li>XPath 式として XSLT 1.0 パターンを使うように変更しました。これにより .// のような記述が必要なくなり、より jQuery に近い書き方が可能になりました。
ただし、 select/evaluate は従来通り通常の XPath として解釈します。</li>
<li>空のドキュメントに append できない不具合を修正しました。また、XMLクラスに XML文字列を指定できるコンストラクタを追加しました。</li>
<li>XMLエスケープ用に XML.escape(str)/XML.unescape(str) を追加しました。</li>
<li>XPath 関数として XSLT 同様の動作をする key() 関数を追加しました。</li>
</ul>

<h3>2013/8/3 version 0.8.2</h3>
<ul>
<li>XPath API の動作が導入するライブラリによって結構異なることがわかったので　jaxen を統合しました（jar 内にパッケージを変更して入れたので、他に jar を追加する必要はありません）。</li>
<li>サンプルで　<code>//foo</code> となっていた部分を <code>.//foo</code> に修正しました。</li>
<li>Translater は Mapper に名前を変更するとともに、Nodes を取得するように変更しました。</li>
<li>XML.load で読み込んだ時にネームスペースマッピングを変更する方法がなかった問題を改善しました。</li>
<li>XPath 関数としてXSLT同様の動作をする document() と current() を追加しました。</li>
</ul>

<h3>2013/7/16 version 0.8.1</h3>
<ul>
<li>命名や動作が一貫していなかった点をいろいろ修正しました。</li>
<li>デフォルト名前空間の <code>NamespaceContext</code> での扱いが不適切でしたので修正しました。</li>
<li>ドキュメントを拡充しました。</li>
</ul>

<h3>2013/7/16 version 0.8.0</h3>
<ul>
<li>XMLIC 最初のリリースとなります。元となる仕様が jQuery API ですので大きな変更は予定していませんが、1.0 までは不具合、要望など積極的に取り入れたいと思いますので、ご要望あれば是非。</li>
</ul>

</div>

<div class="footer">
Copyright (C) 2013 Hidekatsu Izuno All right reserved.
</div>
</body>
</html>